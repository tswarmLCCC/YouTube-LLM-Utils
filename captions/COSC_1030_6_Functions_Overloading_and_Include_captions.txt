okay thank you for sticking with me through some of the denser Concepts like abstraction passing by reference and even a little memory management um those are Big Ideas uh of functions uh but just I've got just a little bit more on functions that I want to cover here and reiterate from your reading and your exercises that um are very useful tools um and and ones I want you to be familiar with because there's often problems that that are solvable um if you just know the right tool for the job and sometimes the right tool for the job um Can involve a function is long as you know all the ins and outs of these things so one of the ideas other than what we've already talked about with passing by reference and this idea of return statements and parameters and arguments is this idea of um default parameters so parameters you as we've talked about um are the uh the the the variables or the values we pass into a function to do the work so in this case we're printing a day this is probably a void function it is void function and it's taking these three things and printing them out right well um sometimes you might want to give um not make your user input you might want to give the option of of a user in or I'm sorry to your to the programmer using your function I I'm saying user but what I mean is the downstream programmer when you're writing a function you either might want to provide something every time or you might not um in this case it's got a print print style to it where there's two different kind of print Styles American and European well I might not want to always have to write print style equals zero here when I'm calling the thing so what I can do is I can give it what's called a default parameter so if print style is not supplied it's given the value of zero which is super cool um because you can give all of these values and what you can do and and you'll see this in the next slide too is um or actually it's on this one where we we're doing basically called function name overloading so you might might recall that when you define a function you give it these um these parameters and most of the time when that function is called you always have to have every one of those parameters or it won't work you'll get a get get a syntax there actually it we'll say you've given me a function name with three parameters and I am expecting four well if you give it default values then uh you don't have to so these happen in um uh is the idea so here your your default ones would have to be last um because uh that's where the it would put the zero in and you can see what happens here is for example um we're giving it um uh the um sorry ah dang it we're giving it a print style of zero and it's going to default to American but then when we actually want to use it for European we actually just include that that other print style uh print style equals one now you could always you could certainly put print style equals zero in there and work that's fine but you don't have to as the idea so gives you some flexibility in there and gives gives your your your program a nice way to say this is the default Behavior but I want to do other things with this as well give you flexibility in your design um function overloading is very similar in in instead though you're giving it two different functions with VAR different types or different um numbers of of parameters so uh you'll notice both of these are called print date um and one's called print date uh with or I'm sorry different numbers or different types different you can do either right so a a function signature consists of the name and then both the number of parameters and the types of those parameters so this first one takes three different um parts of a date the day the month and the year the second one using the same name takes instead a month um as a string and then you know everything else is the same and they're both print functions um the idea though is that they just print slightly differently um given uh different uh formatting options so the um so you got a lot of flexibility in how you use this thing and um again promoting code reuse which is kind of the next next point of the slide here um you know think of these things as many programs that if you write them with all of the different ways they can be used in mind and you tuck them away into a file you can use this for you know your next project or your next couple projects or years you know um there's U you know that that's how software gets built there's parts of Windows that I'm sure are 20 years old right they just have worked forever you know probably how it describe you know puts my stupid picture on this screen right here doesn't have to be Rewritten every time somebody every um every time somebody writes a new program for Windows that uses my web camera instead they've written functions that say take this video stream and put it in this little video and and here's how you record it and all these things well you can do the same thing you can you can take these programs break them down into small parts um and um give it all kinds of different functionality uh um and and use all the different ways you need to use it and build it over time but maintaining and and and maintaining and building upon your existing software Library as opposed to building it from scratch each time that's that's how we build bigger and bigger programs and we get into you know these cool worlds of video games and massive databases and AI right um some of the stuff we're using in AI these days has been around for 20 years we're just using it in new new new novel ways with better Hardware but it's not like they're writing the code from scratch each time now they're certainly writing on top of that code from scratch there's new ways they're using it but but um some of the data structures and things like that were built years ago right they're not Reinventing this wheel every single time they they come up with that like a new chat GPT or things like that so that's the idea of abstraction where we build small programs reuse them and make sure that they're done well uh you know written well and and we reuse them um one last thing that this is just tucked in here uh because I mentioned it earlier and it's also in in this chapter in the book um you know the this idea of writing functions and things like that right here um we have you know a print date that's used in a main program but there's nothing to say that this couldn't be tucked away in another file and we even talked about that during testing didn't we where we take it and uh and put it into its own file um and that's what we're talking about here um and include it you use this hashtag include uh before hashtag was even cool that was back in the '90s uh when I first saw that it's it's been around since the 60s I think or 50s uh with with c and C++ but the idea is that when we use this include directive and and there's plenty of details on how this works in your book I'm not going to beat it to death here but the idea is that we can take basically parts of code and inject them into other parts of our code to basically use a bunch of different files to make a long program even though each individual part isn't that long um again it's it's this idea of simplifying our workflow and making sure things work in one place before we get much more complex so we you know we build small we test small then we build a little bit bigger with those parts and make sure those are working together nicely and doing what we expect we keep building and building and building um until we get something uh something you know to to the extent that uh we build some really really amazing things but each part of those things is is kind of its own little program and usable by itself I mean think about a car right it's not like each wheel is like designed independently from each other right like there's not one that's like a triangle and one's like not three times no they're the same thing just slightly different uh or SL use slight slightly different like you know two are in the front two are in the back right and left right but than that they're the same part well we do the same thing with our programs we build parts and we put put it together um if we're doing it right um don't you know and I think I talk about this a little bit uh where' I put it I threw it in here and I kind of there's this idea of it's called spaghetti programming I can't remember where I wrote it um I wrote it in this slide D yeah I think here doesn't really matter I can't remember where I wrote it um but uh you know a very um a very uh common thing that a lot of uh uh programmers will do is basically keep writing parts to their program as they need them right I'll make another variable for this I'll make another variable for that you know this routine and what you'll do is you'll end up like re you know pointing back to parts of your code um that uh probably shouldn't be used for the same tasks or weren't designed for it and it's called spaghetti programming uh where you you kind of start you know okay I'm going to go here and then I'm going to go back here and I'm going to use this variable over here P point to this thing and that's going to you know do the 43rd thing from this file and eventually you're going to lose track of something something's going to go hay wire and you're not going to be able to track it down whereas if you build small little parts of it um and make sure they're working and doing exactly what they want it's going to reduce a lot of Burden from your mental workload your brain um and you're going to be able to get a lot more accomplished with small built-in blocks um than you will if you're just trying to do one monstrosity of a program from Once uh if I can impart any one thing uh in this whole course frame um to you it's it's build small building blocks test them and build on top and reuse code um and don't be don't be afraid to go back and revisit your existing code either and improve it or redo it if it doesn't do what you want but the idea is that you're keeping your ideas small instead of building these huge things that just you know think about run on sentences probably how I'm lecturing right now a little bit um you know those are hard to follow well programs are the same way so anyway enough enough waxing philosophical about abstraction I hope I hope that all makes sense um and if it doesn't like always please come see me um a lot of material on this unit it's a big unit um it's a big conceptual unit big step forward for a lot of programmers um and it's something that I I value a lot um about programming is this idea of abstraction and modularization um and things like that and um you know outside of just picking up a tutorial or book I hope um that your time with me as an instructor I can impart at least this part of of of wisdom I think you'll be a lot better off U I know you'll be a lot better off if if you start this early in your career and work that way you're going to you're going to be a lot happier with yourself and you'll enjoy programming a lot more so okay come see me if you need any help on any of this um I'm planning on spending a good chunk of time in this class as much as we can frankly before we move on to a even bigger idea of abstraction called object-oriented programming so look for that coming soon thank you