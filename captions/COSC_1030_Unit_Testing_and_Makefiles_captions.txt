this lesson is going to expand on uh what we started with with the make file lesson um in the in this unit um and uh introduce this idea of unit testing uh both with and without the use of make files um unit testing is the idea that we take small parts of our code um you know usually functions or classes our typical targets for these things um and uh basically make a new kind of program um aside from our main program that we're trying to write that just tests individual Parts this is super useful um because it really can make help you focus in on one small aspect of your uh program if you recall you know how we started with the ideas of abstraction and compartmentalization uh even back in 1010 but certainly in 2030 um th this really is a tool that uh kind of rebuilds or builds upon that idea so we basically make small parts of code and we test the heck out of them um and instead of doing that manually we write a different kind of program that does that for us um and that's that's the idea of unit testing or testing in general so um in this unit we're going to um uh build with uh C++ uh and it's assert uh function um so the first thing you need to know about assert is that you need to import a library for it called C assert it's part of the standard template Library just like um a a lot of different things um and with that we get this assert function um this is covered in the zybooks reading for this week but the idea of zybook of assert functions in general is that you can pass an expression to it so here we have an expression called Fibonacci and um basically uh this will be run Fibonacci will be run it's defined up here just like uh anything in our functions unit so far um it'll run and it's evaluated this is an equality operator of course um and if this returns true it keeps going but if it returns false it actually throws an error when it's being run and I'll demonstrate that here in just a bit but um the idea is this won't even compile um when if that if that's true um now sometimes that happens when you use user input as well but uh for our purposes today it'll be when we we actually run the thing so um just some bones about that so the idea then is we might write a program here called uh so here I'm in the uh Source directory and this is the CP I'm going to close all the other ones except this one for now just to simplify our our screen here uh we write a main program uh down here uh that takes so there's three function or two functions there's the actual function we're testing and then we actually write another function just with test just to segment that out and then down here uh we um are uh I actually oh yeah we we both test it um uh oh I I did both here I'm sorry I I actually uh let me go ahead and get rid of this because I think I did this oh no it it tests them and then you actually run it as well uh yeah I didn't mean to do that um let's go ahead and comment these out we're not actually going to run this here sorry I got a little ahead of myself with the uh the way I uh was demonstrating this I did did uh things in different files anyway so the whole thing will just run this test Fibonacci so if if we go back uh and we go ahead and just do g++ like this and we type you know our source directory oops I'm just using a tab here if I can actually do it so we go down to Source like so and then we can do uh CPP is just our our test example um so that'll run and then we can uh then we'll have an A do out like or a.exe on Windows uh just like before of course we could have um we could have um H did I actually make a mistake here uh but that that's actually what we want I I thought this actually passed though uh see is it I think oh did I actually introduce intentionally yes I did yes I did so but that's a good example um so this this test this this is bad code right uh we would want we would want this to fail because I've got a bug here don't I so let's go and correct the error um that if n is equal to one we return one right so let's save that and then let's recompile real quick and then run a. out exe and we can see that our tests uh did indeed pass because it compiled so that's the Bare Bones of how you can use assert right so just just to reiterate that I want to go back over that again we've got a bug in our code you know this is a recursive recursive uh function that should this should be n equals 1 it's the base case of the recursive function and if that's not working none of these are going to work um so if we recompile here we're building this and we run that again we're going to get a blow up and says assertion failed right um and of course there's ways to actually make nicer nicer error messages than that but uh um so yeah we we'd want of course fix our code here um like uh like good programmers um and then recompile it make sure it works um and uh run through our test cases so we've got all these test cases this is how this should behave so the idea is of test cases is how do we know what to put in there well um there great question right the first thing you want to put in there is of course just the sanity checks like these ones like it's easier with math um but you can do it with anything you can do it with strings and things like that so you know if I wanted to for example make a string function that takes the first letter of um of of of every string that you put it in uh put or every word that you put in um you know I could certainly you know you know say it takes like this um well here let's say let's say like I could write something like this where uh let's say upper and this will of course or uh uh camel case we could do something like this where we might be like like that we could certainly do that now of course this is going to fail because this there's no function called camel case in here but we could do a lot of different things and we could uh we could you know as we build things we could combine functions and test functions on top of functions you can use this just all the way up um these are very simple examples uh but you can test not only the base functions but even functions that call those and look for expected output basically anything you can compare down here any two things and you're not limited to equal signs you can use greater than less than uh those are really good for random number generators on your final by the way you can write a random number generation function um you know uh for example if you're wanting you know a range from one to six you could write the fun you know use the random number generator and then um you know do the mod six on it like we like to do for random number generators in a range and then you know a floor ceiling that and then make sure that uh you know as you run through different random numbers you could Loop through a million times and say hey uh or maybe not a million maybe a hundred would be sufficient because you you want these things to be kind of fast um and and say you know if anything Falls outside of the range of one and six so it' be greater than or equal to one and and and less than or equal to six um then then you uh uh then you fail that all right you could write those kind of statements as well um so moving on um very useful in its own right just just within the functions themselves in a single single file program like this one but we introduced the idea of of um of oops sorry let me save this just because I changed it around a little bit Source controls but yelling at me um we introduced the idea of make files uh recently and we can totally take care take advantage of that I can't get back oh there we go um we can totally take advantage of make files in in that way because we can um we we can start to build more more programs uh called test harnesses um so this of course is a test harness by itself uh but if you uh if you're building something like this say say I've got a main program here that uh you know kind of does this you know from our from our uh make file example but then I've got another one that you know has got this function uh that does this where like its whole job is to input a number so let's go and run this let's uh and and we take a look quick look at the main main file here make file sorry uh let's go ahead and open factorial up just so we have it open um so this expects uh a person to take in a number um and then it it just reads that in and of course uh spits out the the factorial of that number um in our make file you'll see here that I've got um both the the compilation here and I use the CPP when I'm compiling uh there and then um factorial targets the CPP so the compilation goes down here um so that you might recall that we've got the we can use uh these so it's just this is just g++ um and then uh the source uh factorial program which we're talking about right here and then it's going to Output that to the binary directory here um and we'll see that in just a sec actually we'll see that right now so I'm going to go make factorial right you might recall this and but what that's going to do is find this rule sorry I'm on the wrong screen find this rule say there's a dependency so it's going to make it and then it's going to um say okay uh it's going to use this to make it after it echoes and then it's going to return here and try to run it for us so that's what this is going to do and let's go here and there we'll see that it works just fine it does exactly what what we want we're going to put say give me the fifth factorial and of course the fifth factorial is 120 that's working great but what if we wanted to test this so this is this is an example of an actual program you might actually give a user right something that expects users but maybe we want to test this as well well um there's a couple ways you can do that but the be the well the simplest way I don't want to say best I want to say temp uh simplest is let's use our uh this a new directory called tests and let's put test harnesses in there so let's ju in this case I've just copied the code just copied the factorial code um into two test harnesses so I've got one here that's called working and we'll start with that um where I've got the same code and then it does a couple a couple test harnesses for me and outputs for that um and then in my make file if I go back to my make file you can see here I've got these test uh these test um two two sets test I've got factorial working uh this one builds it this one tests it and then I've got broken as well and we're going to demonstrate both here what happens when you call those rules so um the cool thing about this is it's taking all this code and wrapping it up in one command force right so if I if I clear this out um and you know what I'm going to do I'm going to do make clean as well which gets rid of all of our all the stuff in the binary directory here cleans this uh directory up I'm going to do make test I'm just going to copy it factorial working make test factorial working like so um and that's going to find this rule it's going to get compiled just like normal and uh we've got a separate one to build it you could certainly put the build down here but keeping this separate gives also gives us the ability to build it separately uh from it if we're if we're dealing with a syntax there that's sometimes nice and we'll see here it goes in and it's basically saying that it's in factorial working and the testing started and it succeeded in returned right um by so factorial working of course Works uh that's why I named it that right we've got that same good function here um and and our test harnesses are good but I built one that's uh broken test broken um that basically has a a small err in it where uh the um uh what did I do to break this I can't quite remember oh it's zero this should be one that's what it was uh let's just make that comment for you guys so when you have this yep right so now when I go to here in our make file of course I don't know why that keeps closing but it does um we we we're doing the same exact thing but I've got just got a slightly different uh command so we just do make and we'll see here that the assertion fails it's it went in there it's saying it's testing started and because we we printed it out in the Echo uh we and we could echo in here as well uh we get the error and we can say oh there's a problem with that code right now just to just as an aside um I I really struggled with this next part uh only because of of sequencing of of how the program works here at uh computer science works here at lle C the uh the the idea that you have to copy this code isn't ideal right we've got it here we've got it in the factorial itself we got it in factorial broken a broken version of it of course and then we've got it in factorial working here as well right ideally you wouldn't want to copy that code everywhere around um and as a matter of fact you don't have to uh there's ways to import functions into programs so you'd put them in what's called an object file or well you'd build an object file from another source um and you'd link them via headers we don't cover that uh in 10 1030 though so we we we do cover it in 2030 um so I went ahead and copied them in here um and it's not that hard to copy code you want to test in here for test harnesses you just need to remember to to to put it in here and write single single function or you know all Allin one test harnesses where the function and the and the test harness are in one file but you could keep one copy of this code which is great practice uh this is not great practice what I'm doing here but to illustrate to make it simple for you um uh to to start with this kind of stuff you'd want to put a copy of your function that you're testing in with the test hardness even though you're using it in another program like this one um so again this program in in source is the one that I would you put in front of a user or maybe it's your final you know the thing that actually calls your final but the one in the test harness is saying okay I'm testing this function or this series of functions um so when I go back to the make file here I can actually run all of this like um I'm going to actually tell it to uh uh so all here you might recall uh will run Main and it'll run factorial working and we're going to have it do factorial as well it's going to do all of those for us um if I get don't give it any arguments um it will it will uh if I don't give make any arguments it will run everything in the first line or first first rule I should say that it finds and in this case it's going to be these three and of course it goes down their respective chains we've been over that plenty um and we'll see that happen here so you can test test a whole bunch of things here so this one's actually going to run it because I'm doing main um yep and everything uh everything worked uh oh maybe not working let's see factorial working oh it's because I it's test factorial working now sorry just just a rename so you gotta got to make sure your names are strong and these things can be a little cryptic so as you refactor this by what I mean by refactors rename things in here make sure that of course you are you are um keeping things straight so let's do that again all right that's going and everything worked every we got back to a command line test succeeded and then of course at the bottom of these you might recall we got this little guy which cleans up our bin directory because we now got four different binary files in here um so we make a um a nice little make claim that just gets rid of all of those for us of course we don't have to do that we could also do that if we wanted uh if we wanted to um have it clean up after itself we could do this too uh where it will run each of those is that in the right order let's let's try that I'm not actually sure if that would work let's find out I think it does see there they go let's do this and then yeah make clean did it ran first unfortunately now you'll see here as I run this again make clean uh oh I'm sorry it's because I named it wrong I'm just being a little silly let's try that again I you know I'm used to typing make clean all the time let's let's run that again and we'll run this guy and there it goes it cleaned it up at the end so that that's how you can do that and it cleans up after itself Isn't that cool um just really neat piece of automation for you there so um that's a little bit about unit testing of course there's many many things we could expand on here um I'd certainly uh recommend testing your functions as you're developing this uh certainly simulation Loops you could have your simulation Loops engineered in a function and and output certain things under certain circumstances um one note about random number generation is when you're developing you might want in especially in your test harnesses you might want to do what's called setting the seed and we cover that um in different units so I won't go over it here again but setting the seed controls your output um so for example if you set a seed uh and the seed's just a number that you give it that always basically your random number generators will always uh run the same way so you while you're running um a simulation uh you could say okay I'm going to run this through this and say what should it expect and as I change this uh you know I should expect that same value you know it might be the standard deviation uh it might be getting the standard deviation of a simulation or it might be the number of outages on your final in a given run for you know a set of days uh you know within within the you know one trial um lots of different things you can do so anyway in your assignment um I'll be asking you to write some of these test cases and if you want you can play with make files as well I'll give you this is an example um and then what we'll do is probably just have you change this up a little bit just to kind of get used to this bigger project structure but uh it's really nice having these tests in there you will uh building these up front will save you so much much time down the road of uh saying uh you know when I've changed something it might have broke another thing right say you got like five functions that all call each other um it might not it might not be the first function uh that that is broken it might be something down the rock down the line um that uh your your function uh messed up uh you know so if I know I don't have my camera on I'm kind of teaching with my hand sorry if function a is called by function B and function B is called by function C and you write don't write a test case for function a but you do for c um C might be working great for a while and then you change a um and all of a sudden C stops working you might be looking in C like that's worked forever well if you if you write good test cases for a um that that might point you in the right direction of what where the problem is so um hopefully uh you find this as cool as I do this is really a step forward in your in your engineering prowess uh this is what we call you know a a bit of software engineering certainly programming uh where you're you're being much more systematic and systemic about your design as a matter of fact I would recommend writing your use cases first I know that sounds really weird uh but the idea is write your use cases first before you write your code um so you could do something like this where if you're writing a new use case let's go and test and make a new file and we'll just copy let's just say you know starting out um and we just we're just going to straight up copy factorial here for now I might instead of so say I didn't have I didn't have a function here right I might do something like this where let's say uh new function if I wanted to I could just say something like this where I'd say you know my first function uh let let's say the whole point of this is to I don't know write you take a number and you know Cube Cube it let's say that's what it's supposed to do so uh let's uh uh Sor go back here we're starting actually uh uh cubic just something like this and then we could do something like this and then let's say we've got our new function here we give it two cases right or we give it one case let's just give it one case for now um let's say I don't NE necessarily know how to do this um and I'd say you know okay the cube of two I know that's eight right I know that's eight in my head so that's my test case I haven't even written anything up here yet so all I'm doing right now is returning eight no matter what comes in here I'm returning eight and so I I can fire this off I can just uh do g++ uh What's this called this Source new function or starting out sorry did I save this yet what's going on here oh it's a test sorry like so now of course we'll get it then we can just run a. out or a.exe right so I'm working and like okay that works of course it works it's doing exactly what I told it to but the cube of two should be eight right um so when I go in here and I start to implement this I could say return n uh times n let's say I don't quite understand what's going on and I say times three that feels like maybe that raises to the power of three I don't know what you know why you'd make that mistake but let's say you did right so now when you run the test we get a fail right and we're like oh what's wrong you know I I changed this well that the idea is that because we wrote this test up front we catch this runtime error really quickly and we can correct it so that that's kind of a cool example of that so um anyway I'm going to leave this video here it's getting a little long um this is you know one of my favorite topics of this unit certainly one I've been wanting to introduce for a while um both the structure that we've been talking about uh let's go to clean up everything let's go and get rid of exe here because I I'll be actually checking this into GitHub for you guys and giving you all of this code in just a bit and let's do a make clean here getting rid of that um so you can just see how these make files really get useful in a hurry right so we'd want to run a make file uh on this F you know on this as well as we're doing it so I don't have to compile it all the time and things go in the proper directors so anyway enough of that please let me know if you have any questions about that a super fun topic but it's def definitely a different way of thinking um talk to you soon