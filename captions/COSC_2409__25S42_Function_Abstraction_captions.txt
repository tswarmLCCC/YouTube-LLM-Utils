welcome back to our python lecture series um in in this particular set of videos we we're talking about python functions and digging into the nuances of both the uh nature of functions and how they're implemented in Python in this video we're going to be talking about uh the idea of abstraction which is one of my favorite topics in computer science especially as we teach it here at lle c um and it's really a first step that a lot of programmers uh go through where they start to move away from just getting things to run in program and really um building reusable code and uh and avoiding repetition making your code cleaner easier to organize uh and maintain um and read frankly um uh in this case uh we're going to start off with a simple example here of some simple code uh that uh uh you know we might write U as we as we just get started um so in this case we're doing um we're building five variables Square 1 two 3 four five where we're basically just taking the square of two two numbers or I'm sorry of a series of five numbers um and squaring them just multiplying it times itself um we store those in variables and then we print it out right um as you might expect this is fairly straightforward I'm going to clear our output here just so you can see it come uh through here in our notebook um and you'll you'll notice that we just get you know a very simple string outputting this well what if we wanted to change this um you know for example to uh be a cube instead of a a you know a a square right well one thing I could do is I could start to write something like this where it's you know times one right this is something that that we might do um you know very repetitive uh and kind of a pain in the butt to maintain you can see it's very slow and then I might even want to start to change things like change this to the word cube right um like so and you'll notice I'm breaking like this code would break right because it's well if I if I restarted um it turns out that these these were actually uh reinitialized um and um there but if I if I restarted the server which I'll go and do let's go and restart it doesn't take too long to do locally um you'll see that this breaks which it should right I'm defining Cube here but I'm calling Square here these are problems that run we run into um what I've done here is called refactoring where I rename things uh but you can see that it can be an arduous task where I'm renaming things and uh breaking things as I do it or got inconsistent code here um luckily functions give us a great way to kind of combat that I'm I'm undoing this by the way just so I can leave the uh the notebook in a state that uh that's very usable when you guys pick this up so back we're back to this where we're back to squares well it turns out that we can use functions as we've uh talked about before to store blocks of code right and one really nice thing about that is we could do things like this where we store um we take what a parameter we Define a parameter in our function um and we give it an argument we pass a number in and we reuse this block of code where we're we're multiplying this right so we can run this and we see the very similar very similar text but if we wanted to we could do something very similar like um you notice I re renamed it here to calculate a useful number instead of uh calculate a square um if I wanted to turn this into a cube all I need to do is do something like this and you'll see that now we get cubes because we're reusing this code it reuses it all five times right and we we might not even have code just in a block like this we might have it all over our production environment in a work environment where um we might need to change a welcome text or the way interest rates are calculated or anything like that and so by making a a pattern where we give it a name and we say this is a a solid set of inputs and here's how you do this work um and then we expect an output we can change it in one place and it updates everywhere hopefully that's uh kind of an eye opener for some of you if you haven't uh seen functions before on their power and what they could be doing um you know if we wanted to do something like this where we wanted to do an average of two numbers we could do something very similar like this um and and uh uh and and convert that that to a uh a division or an average function right um and we could of course rename it and then rename all of these as well that that's very useful as well um so pretty cool design pattern there but we can go even further it turns out um if we go down to this next example um here we can use Loops uh so we have C the same exact function here but instead of repeating the the string here blah blah blah we can Loop through a series of values in this case range as you as you might recall I'm going to go and print it out right before we use it here just to uh print range six uh like so and again we're just calling the print function on a function right nothing too crazy here uh got to make sure we get our syntax right and then close our parentheses like so um but you'll see here yeah let's good save that we'll run and we get uh oh sorry we need to do a you might recall uh from our data structure we need to convert the range to a list to actually show it um because the range is is an object in its own right but that's beyond the scope of this but here we see we're getting the range from one basically from one up until six 1 2 3 4 5 and then we can Loop over that range um so instead of repeating the uh the the square or whatever uh you know we want to do we can only we can control that in one place um and we can uh talk about which version we're talking about and what we're passing into it um so we're uh in this case it's square but we could just say you know useful number obviously I did a little copy and paste and we could put that in here right so um and then what what we're doing is using our value uh or our our useful function up here to take in a number um any number uh uh in this case it's I because we're we're pulling that out of our list one two 3 four five and we're just plugging it into a function so you can put variables into functions and they they get infinitely more useful when you do so um and when you do that we're just storing it out we could print this but I think it's a little redundant to do that and then we're printing out a little bit nicely a more nicely formatted number here right um so if I run this you'll see that we get um the output we see down here but again same thing if I wanted to change this to a cube we could do something like this and we will see all of those update or if I wanted to um I uh um the uh we could change the text quite easily and we only have to do that in the one place right we could do that um so you can hopefully see how we can use um functions in Loops to basically take a set of data and apply it to a set operation on that data and then get an output that's repetitive um and avoids a lot of reuse um so that's a uh one of my favorite design patterns to teach um uh yeah uh there's a slightly different version of this by the way where we can take um where we can take a uh a list instead so a range by default it can resolve to a list like this um uh where I can actually just give it the number so say I didn't want to do a sequence let's say I wanted to do every like you know every fifth number I could do like five 10 25 or 15 20 25 right that's certainly something I can do um and then uh that number is just in a simple list here and I can pass that that that uh uh we can do the exact same pattern where we pull the number um out of the numbers list and then plug that into our function and we get very similar uh operations that what we saw up here um but we can um you know just control the data this is a very useful pattern in data science where we load things into lists and um and then numpy arrays down down the road where we can operate on those IND uh directly so um several different uh patterns concerning repetition uh and dealing with uh the functions but um this idea of basically taking a bit of logic in this case an operation where we just do numbers um you know there there could be pages of code here doing a very complex operation and we basically pack it away into a function called calculate a useful to Tool and then we don't have to worry about those anymore and we can reuse it um the upside of that is it's maintained in one place it's clear and concise right this is a this down here right is calculate square is a heck of a lot reader easier to maintain and read than all of these or even doing something like this where we do it right in here right you could do all of this work that way uh but uh in doing it in in packaging it up and giving it a nice name like this it makes it repeat you know a little bit self-documenting where it tells us what it's doing um and uh it's uh certainly if this was like five pages of code to do this calculation um you know it's it turns it into a oneliner that we don't have to worry about and that's the other thing is as we abstract away our complexity we don't have to repeat that calculation it makes our code easier to um we can focus us on what we're doing right now we know that that function is going to give us the square out or whatever whatever numeric value or string value or anything else that a function can do U we know what it's going to give us back out so we don't have to worry about that anymore and we can worry about just the block of code in front of us in this case a four Loop and of course we could then take this and wrap it into a function and go higher and higher level as well this is the idea of abstraction and encapsulation that makes computer science work um in in in in a lot of ways so um I'm not going to beat that horse uh to death too hard but it it's a very important concept if you have any questions about this idea or You' want some more exercises let me know um it it's a very useful design pattern um all right uh