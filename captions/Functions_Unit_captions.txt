hello we are going to introduce our functions unit in this video um and we'll have some Associated units uh of reading and some supplementary material there in our shell um along with this assignment uh for for this unit um let's see let me pop over PowerPoint one sec so um as mentioned we're getting into this idea of functions and abstractions in this unit um uh we're moving kind of beyond our basic tools and actually that's kind of what my next slide is just about um where we get kind of past the the the the very first very first um Concepts that we cover in the class variables this idea of branching conditionals Expressions we covered in some length um and then finally you know just recently loops and arrays and dictionaries and lists of those things those are kind of though um uh well moving on we'll get be getting into functions and you can see there's not too much Le left here uh in terms of what we call our basic tools and as a matter of fact I'd even argue that starting with functions we're kind of getting into a higher level of tool um as a matter of fact I I actually want to take just a second here just a minute to kind of um kind of congratulate you for for kind of getting through those early Concepts really what you're going to be building on here is not fundamentally different than what you've been using using IF statements and ws and loops and and collections um we're going to be building on those things much like we might start off with a a simple screwdriver here um you know from my workbench I took a few corny pictures today to kind of illustrate that um well we might might do some things where you know we might uh make it a little easier to use this in a hurry where we use a power tool or we might need something that's very precise um so we might build a specific function but really all we're doing is combining the four or five very simple Concepts that we've introduced not that they're easy to grasp but they're kind of you know comp uh you know conceptually simple into some more uh uh um complex things much like we might use different versions of the same tool these are all kind of screwdrivers in different ways with like our bits here and our smaller screwdriver here and this little driver here that kind of adapts to what's needed um much like that we're going to be kind of building different versions of the tools or using different versions of tools but the concept remains largely the same procedural programming branching you know so on and so forth the other thing I really wanted to kind of um mention here is that once you've learned kind of these Concepts in Python um much you know because that's you know the language we're studying it's not too hard to really take these ideas and look for similar Concepts in other languages and as a matter of fact syntax even though it's a kind of a a a barrier to for beginners um it becomes much much uh easier to pick up as you go and you get more experience you're you'll be more thinking in terms of using a ni statement on on a problem or using a w to iterate over a bunch of things and you'll just be looking how to implement that and even borrowing code from the Internet or a reference starting to read documentation or heck even these days using things like chat jpt to say while you know write a wild Loop that goes over a collection of addresses right once you kind of know what you're doing a lot of the headache of actually implementing thing can start to go away much like once you understand what a screwdriver does we can use some of these other tools uh to kind of help us on our way in different ways that are more efficient um and really that's that's kind of just a a good way to you know kind of put a bow on the first first part of this semester um and and just you know really you should feel good about what you've done so far keep it up okay so talking about efficiency we're going to introduce this idea of abstraction and um and functions so functions in their nature are a way to basically take a a sub routine or a a small program and give it a name and then tuck it away that's really what we're doing what we're trying to do um as I mentioned in this first line we're going to try to take our programming logic and get it away from the way we actually do the work uh we started to do that early where we started to use variables to hold our values instead of plugging the values into this distance formula here right um and and then printing it instead of doing that though we might take instead of doing all of this each time imagine if we had to do this a 100 or a thousand times copying this code would be error prone we'd have to maintain if we wanted to change it then we'd have to change it a thousand times uh things like that instead we can do what's called defining a function and what this you can read this is Def is a keyword it says Define a function and then this first part here is the name of this new function and we can call it as such later in our program you have to Define it first but then we we can call it and these bits sometimes you don't need them sometimes you can just do things without passing what are called parameters uh to your function these are parameters when you're defining it arguments when you're passing things to it um so basically these will take values and they don't even have to be the same like X1 here um you'll see is just one here it's not called X1 it's just one so on so on and so forth and then it takes those just for the length of this little program or function and figures out what to do with the information it's been given the thing about functions is you have to give it everything it needs to do its job though it does not see outside of its Little World U most of the time there's ways to over write that but by default you give it these um arguments here to operate in it own little world hence the word sub routine and then it's going to say when I'm done I'm going to give you back this value so in this case instead of doing this and assigning it to the distance variable we could easily put the distance variable over here I didn't do that in this picture but say distance equals c distance 1 2 4 six and we would have got the same exact result the other thing you can do is you can actually use the name of the the parameters with your argument so you can keep them straight in this way start to become self-documenting right um instead of X1 X2 although that does make sense here because we're actually talking about cartisan coordinates where we have X1 and X2 or you know an XY pair height height and width you know on a map same thing here we we actually are passing things that have meaning and nice names back instead of arbitrary variables um just one other note you may have started to think about this a little bit as I've been talking or maybe even before this year unit this has been done for us this is the fundamental building block of starting to build up more and more complex code um you might have noticed we've used things like the the length function Len you know or the print function both of those are functions that are in Python that were done for us and their whole job is to do exactly that take some complex operation and do it behind the scenes and then we give it just enough information for it to do its job and comes back in a much nicer to use format functionally we could absolutely write all the logic to print things to the screen and go in and figure out how to make the monitor work and things like that we could absolutely do that every time we wanted to do anything but instead it becomes much simpler and much uh conceptually taxied on the programmer to do it once very well and this will be a theme of the of the lecture here do it once very well pack it away and then use that and maintain it in one place very key concept here um so let's illustrate that um one thing that uh used to be true before functions really became the thing is this idea of sub routines and what you would do there U much like um options to saw a piece of wood for my messy shop here um we can we could bring the the problem to or you know in this case what we're working on I shouldn't say problem but the the object that we're working on we could bring that to the tool and that's why I took this picture on my table saw we could absolutely bring a board to a table saw right um that's a great a great analogy I guess uh to what kind of used to happen you would put the data right into this machine and you would set the data up to go through a machine and then you'd assign new variables to come out um but instead what we can do is we could use one of these like a a uh a circular saw or a handsaw here that are a little smaller and we can actually instead package up some of the the functionality and take it to the problem so where we could you know be working with our data in our our our main window our main program and just say okay I need a function that's going to take the square root of this or you know find a derivative of this or print it out or you know make a make um you know this character that's represented in memory up here on the on the uh on the on the screen well instead of doing that right there with the code and saying okay half of what I'm looking at is how to do it and half of what of what I'm doing is doing what I'm working on instead we move our function code out into into into bits that we can maintain separately and in isolation and then when we need to use them for real we bring them into our main program and that's really what we're going to study for the rest of the rest of the lecture here um just a couple things though um just a couple pointers um you you know if you if you're starting to write a program and you're you're solving a problem if you write similar code twice it's time to start thinking about abstraction or functions start to think can I tuck this away is there something here that's common um and changing are there's most of this common just a little bit changing and if that if that's true you can take the common part and probably code it up in a function and then the part that's changing a little bit you can actually deal with it in arguments um and same thing you know sometimes um you might want to write a function that just makes your life easier for example on a previous job I worked uh as a database developer and uh to to write um to get data from a database you you write what's called a query um and to do to use a query on a database you have to set up just a ton of logic in your in your code to you know first connect to the database server and then craft the thing that's going to hold the data and then execute the query and then go get it all those things um and I wrote that code probably hundreds if not thousands of times um you know probably at least four or five lines of codes and sometimes you know even tens and 20 or 30 lines of code depending on the complexity well instead once you find yourself redoing that task it becomes much more efficient to make that a oneliner where it says get query right where it takes all that repeated logic goes out gets the data and brings it back and then you can operate it and what what it really does is it frees up your mind functionally the computer doesn't care it's doing the same amount of stuff most of the time although there are some memory benefits to using uh uh and and processing benefits to using functions but most of the time it's just making your life easier where you're not looking at so much code each time but you're looking at readable stuff and then working on that with your your programming brain um and then you know use different output and really you can keep doing this really forever um and often people do um to to make things more more more and more um organized and simple and maintainable uh let's see most of these oh just one other thing and we'll see these in effect here uh there's two kinds of functions the first is like a what would be called a void function it's kind of a side effect function and I I'll do a little illustration of this in a little bit but think of print print doesn't um actually produce anything it does something you can think of um prce a great example drawing things to a monitors sounds or even like maybe you write a sord algorithm and put it in a function and say sort the thing that I give it to you um and it just does it without without coming back with anything um where it doesn't doesn't come back the other kind is return value functions and that's kind of what we looking at here where it actually comes back and says you give me these things and I'm going to give you this back it gives you a value back um and it's it's indicated by the type of variable that this whole expression right before this return statement would would give you um that should be covered in some length though in your reading so I'm not going to dwell on it too here just something I want to highlight is the difference between those two things um so let's talk just a little bit again about um the structure here just a couple Graphics I found we started with deaf we started with the word def which I think stands for Define in this case and we give it a name and then we give it parameters you don't have to if you can do your uh if you can do your work without any input think of this is the input to a new program think about our and then the output is the return statement so if you think about our box I think I've got one here yep um we take arguments we put it in the function and we get output right we can do it that way or sometimes there's side effects so these are kind of the two kinds of um of functions some give us output some give us side effects but both of them take input do something and give it back and then we take that again and we we move the the output here into our other program right so this becomes that's why it's called a sub routine it's doing a little job as part of helping us up with our bigger job um and then we see the body very similar but just getting to the syntax you're going to need the word def you're going to need the name of the function any parameters you're going to use and if they if you're not using any just put the these two braces here to say there are none and then this colon which you might recall starts a code block the rest of this code block is where you'll Implement your function this is where you do your programming to do the sub routine and then finally if it has one you return the result so basically this is taking X and Y and it's doing it's actually printing something out so there's a side effect and a return here um and then it's multiplying the things storing it into result and again these wouldn't live here you couldn't call result after this you basically be uh grabbing U uh you'd say you know give me the the uh let's call it let's call it product you know because when we multiply it's it's the product of two things uh you could say product equals multiply 2 comma 2 and then product would have the value of four but you couldn't call result but um result only lives inside the function here um as long as it's needed to do its job then it goes away uh let's see you know I used I'm not going to jump into this but the idea here is that basically we wrap our function around memory um but that's a little little in the weeds for what I want to do tonight uh we talked about this already you know just the idea that print would be like a side effect um just going to leave these up just for a sec make sure I uh didn't cover this these are just two more slides I found kind of the same idea um where we return a value and then here's an example of actually calling the function so we've adder in here it's only always going to take 10 and 15 right um but then we're assigning we wouldn't you notice we don't actually use uh after we come out of our block here we're back at the main level of our program so you you call this it indents it this is part of the same little program but here we're back in our main program so here Adder then takes 10 and 15 and it actually assigns its return value to Output number um and that's that we'll see that many times and then then it can do something with it but you couldn't for example print num one here or print num two uh because they don't exist in What's called the memory space for this um and then lastly we kind of do the same thing with taking a number where instead of adding two numbers we take any number and we pass it as a parameter uh an argument to the parameters and it says take take a number add five to it and then we could assign it to a variable here we don't but we could so I'm going to jump into two little bits of code here let's see we're 17 minutes in I'd like to this fairly brief because you're going to be doing a lot of work on this in the coming weeks um and certainly the reading should have given you a really good um uh the guid lecture design books should have given you a really good background on this let me grab vs code here though switch over to that let me switch over to that where you this code there it is okay that over here like so so I can see what I'm do um so much like what we T just talked about um this is the one I just printed um let's go ahead and use our debugger to kind of see what the heck's going on here um so I'm just going to hit this we'll do what we did last week excuse me sorry about that I'm gonna run a debug just so we can get an idea it's going to give us a little more visibility into things so we'll run into bug and python file should all fire up I would think yep so we've got nothing going on here as I step into this with f11 you might recall um we see that X1 X2 uh y1 and Y2 get populated then we have this distance variable where it's taking all of those and doing a calculation right um that's uh basically going to print out our distance and we even see see it such but we can see here we can run this and I think somewhere uh uh yep we get a cal distance so this is actually now been defined it went over this and it said okay you've given me a program and I I know about it now the key thing I wanted to illustrate here is you need to run this uh to for it to work it doesn't know about it unless it happens to execute and that's why you usually put them at the top of a file so they all load before they need it and you'll see here though that uh well here let's actually give it a name let's say say R distance equals so just so we can kind of see that and let's just go here and uh it did not I think it's because I added it to let's let's go and do that again um just boom boom boom boom boom it's going to call it it's going to go in there you can see now it's actually creating um our what's called a call stack it's actually setting up this workspace right now to do this work and it's going to return it here and then here it's going to then assign it we're going to get a new variable with our name and this is actually going to do the same thing down here I just use set this up to illustrate the uh the the namings that you can actually call it X1 equals one so you can keep them straight uh if if uh you start to mix up the order of these things sometimes there well actually in this case they're very important what goes where is very important so you can actually use the names to make sure they're in place and if you do use the names they don't have to be in the same order which is nice um so anyway enough of that let's see here let me go back to the other lecture video and let's talk about why we would do this a little bit just a little bit more so let's uh let's kind of clear our brain here I know speaking of clear brains let's let's clear our python window so we can talk a little bit we don't need that we might write something like this let's say our boss wants us to convert a bunch of temperatures from Celsius to Fahrenheit so we go out and you know he writes us a quick text or something says hey I've got the these and I need them converted um and let's let's say there's only six but it could easily be 6,000 couldn't it um you know because computers can do that so we go ahead and we go Ahad and say all right the first one he gave me was 20 the second one he gave me was 50 so on and so forth and we read a nice program here that that does does what we would expect right it prints these out we've seen this a couple times before and we go in and we're we're tired it's a Friday right and we type this one in and uh and we run it we don't even think about it right well all of a sudden we're like oh no we we type that and we may or may not catch that right this looks like okay outfut to me right if I wasn't really you know if I didn't do this intentionally I might not catch that or you know uh maybe this was supposed to be 20 instead of 21 and as a matter of fact I think down here we actually do that um so we could type in the the thing we're working on wrong or we could type in our formula wrong this is some of the problems with repeating code um so when we're do we're doing something very similar over and over again here calculating this this conversion to temperature um so what can we do better well we we learned one already we can use a a a this idea of a list in this case or we could even use a dictionary we want to add names to the thing um and we could we could create this thing uh just like uh just like we did have done previously and I'm just G to kill this just to clean up our code a little bit I think this should still work yep so we' got a temperature list here and uh and what we could do instead is we could move all of this logic and take this this part our input to our our little statement here we could do that and say okay I'm only going to do this once and by doing by looping over this thing there there indeed we get exactly what we're looking for getting all these conversions back out so this is certainly an improvement this is certainly an improvement um but even then like we're still kind of doing a lot of this if we had a bunch of different formulas um you know this isn't the most readable thing like you know may maybe we didn't use a great variable maybe we call this X and we called this x we called this x list certainly this still works right this this is this is perfectly fine uh well as long as I do this as long as I do that uh this work just fine for us um but again we have to remember to change everything in all those places that works right I'm going to undo that because I'm actually going to ship this along with the assignment to you guys um but what what's better than that even well the codee's in one place but we can instead to find this function if we run the function here then we get this nice thing instead of print temperature divided by 9 or times 9 divided 5 plus we just it reads a lot nicer instead where we Define a function and we just say print the temperature conversion of temperature so for each temperature in our list we start to get more englishy and what we've done is we buried We buried these you know not terrible details in this case but they could be this could be you know pages long of code and instead of doing all that we just say hey go do this thing that's understood and it's going to take temp and print that and certainly that works right so that that's a nice Improvement in readability um so let's let's play let's let's pick on our boss a little bit the same boss let's say instead he said oh I meant to say you're wrong he's mad at you he said uh you know go from Celsius to F Fahrenheit but really he wants to go to Celsius from Fahrenheit the numbers he gave you were in Fahrenheit so instead so what we had instead up here um was this instead of you know going out and changing all of these things all we have to do is redefine our function so instead of multiplying times 9 basically we reimplement this function instead and we just change this one little bit of code it's got the same name and then let's say we've used this all over the place well guess what that just works right that just works because it's it's a named function and we just change our code in one place and let's say this temperature conversion function which just all over our Enterprise website and it's in thousands and thousands of places well be we could have just put this in all over the website and taken weeks to go through and change it all or we could have defined this routine that's well understood well documented and well implemented and then gone in and changed it here instead just one place and it updates everything because we're modular izing our code we're taking it we're doing it well we're refining it perfecting it and putting it on a shelf for future use if we need to come back to it we can in this case you know because our boss told us the wrong thing um but there can be many many reasons to do that another great reason for that is to implement something simple and then use that and then as you understand things a little bit better go in and refine the the function that does it but it still Returns the same thing and you improve the quality of your code or handles things a little bit better um but you don't have to go do it everywhere you only do it one place so some nice justification there and let's say he even does uh he wants us to do um a little bit more and he wants us to print things nice right so uh what we could do is we could make another function and we can instead of use print we can use this side effect where we make a formatted number and we look up I don't know maybe on stack Overflow or in the python library or or even chat gbt we learn a way to to make this only print instead of all these decimals we learn a way to um instead we learn a way to make it just print one so we just change our code from print to print nice for boss right where we're doing that same thing we're just doing a little formatting and then we actually just do the same thing we just print it so we're wrapping print inside of a function and then we're just making it do a little bit nicer print job down here so what that could have looked like if we hadn't done any of this to make it print nice for our boss would have been all this code isn't this much nicer to read um you know as um instead of trying say oh I can't remember exactly what the f strings are for this from our strings unit or you know the order of operations or oh my goodness I forgot to add that minus sign here all of that can go away and we just get this nice little two line thing here where we can work on a lot of things and if we ever need to change it all we need to change is this so we wanted to just make it two decimals well guess what there there there it is that's it instead of doing something like instead of doing something like this and then this this and this right oh I made an error even there 21 let's go and see what 21 of those look like yeah see so easy to make errors when we're making changing many many bits of code we're doing it in one place the nice thing about doing it in one place so if it blows up this is kind of funny if it blows up in computer science if you're doing things right it will blow up spectacularly and you'll know right away that you made an error right so just some justifications for these things all right let's wrap up the unit uh we have some nice predict things uh just very simple uh reinforcement to couple with your your guided learning uh the first is you're going to kind of predict what's going on in each of these these are very simple uh just uh really tell me what these are doing in your head investigate we are going to do the same thing you're just going to answer a few of these these questions just uh some things in different formats but what are each one how many are there things like that uh start to understand the difference between parameters and uh and arguments um things like that then finally can have you write a very simple um uh adaption to some starter code here uh where you um are changing the name to something useful um calling the function with a new uh new uh uh a new country name and then we'll actually have you write an input statement um and store it into a variable and then uh then then doing a little work there and you can print it out there again these are all just for your own learning make sure you have good understanding of these things but this is a great exercise to go through quite quickly this shouldn't take you too long to kind of say I'm getting it or I'm not getting it that's really the key of these things and then finally we have our weekly assignment um which I have actually just copied these in here you're going to name make four functions and you're going to have users put in two numbers um and uh you will be passing those to your functions um um then uh you'll write a little menu system uh using input um and if you need help with that part please let me know um and then you'll call add etc etc based on what they they take so the this part I'll just tell you I'll give you a little bit of a clue here this part will be a wild Loop so you're going to be writing functions outside um and then writing a while loop to collect the user experience and then you'll use the functions to do the work I do not want to see the math in the main wild Loop though that's the main thing for this week so I think that's about it for functions or at least the introduction uh we'll see how this goes uh this is a hairy unit it's kind of expanding what we've done and I I expect I expect a few questions and things like that get through the early parts of this assignment um early in the week let's use our open Office hours and office hours and certainly email and things like that to ask questions early and often um so welcome to the world of a little bit bigger Computing this is a very exciting time between last week and this week these tools really start to um Empower us quite quite quite a lot here um anyway thank you thank you for sitting through my worksh sh tools um I always enjoy that a little more than iation