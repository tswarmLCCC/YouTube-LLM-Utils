welcome uh back uh to our continuing lecture series on kind of the the building blocks of python some of the fundamentals we've previously covered um you know an introduction and some control structures and we're moving on um to a the the first uh The Big Unit where um we discuss an abstraction technique and an organization technique called uh functions um functions are a fundamental building block of computer programming if you've had any of my other classes I I hit them pretty hard early and often um and we're going to study them here for a couple a couple video lectures in this unit um you you'll notice um if you're continuing just in sequence that I'm um we're going to use a little bit different uh bit of a presentation format here um in the code that I give you this is called a python notebook we will cover it in Earnest um in another unit video uh lecture and how to set these things up and all of that um but for now um know that they are basically are a mix of markdown text which um I can use and I can even edit right in line if I need to um but also um code here uh that I can I can run in the notebook without having to jump down to the terminal you can think of these blocks as essentially a terminal entry um that's a little bit nicer um but we get the output in a nice easy to way uh easy to use way and I can get away from um trying to uh Nagle with the terminal um I wanted to start off with the terminal uh just to show you how to use that uh both in terms of executing files at the time or um or or you know using it directly uh you know from the uh typing python into the um into the into the actual console um you'll notice that I have a lesson docs folder in the in the code that I'll provide to you this week um along with other things in here there's a um there's actual code which will go over everything that I'm talking about here um uh in in more traditional python um and then uh um uh and then so you can grab the code right out of the markdown documents by the way if you haven't seen these markdown documents um if you open them you might see the actual formatting code but what you can do is right click and Go preview here or go uh control shift V and you'll get something like this um which looks like a notebook um but you'll still have to copy this thing out um anyway all the code's there so you can copy this out put it in your own functions uh if you want to as well anyway uh back to our notebook here let me close all of these uh except that one and we'll get right into it so a function is a essentially a uh a nam space that holds a a bit of code in Python um they're reusable blocks of code functionally uh not to be confused with confused with functions um but the idea is we basically store code in a in something called um a namespace um in this case in our first example here we're defining a a function called FIB um and we use this term defa here uh that stands for defined function and that's followed by the name of the function and then any arguments we'll come to what arguments are in a little bit we can provide documentation anywhere after those um they're followed by a colon and they are stored in a block just like functions I'm sorry if statements and w and and other things that we studied previously are but basically you need an indent here when your indent ends uh that is the end of your function um now um so I could I could do things like this I could add lines down here um as well but you basically you need to at some point have a um a Hardline in the notebook here it doesn't matter uh but um those are defined those are um those are uh those are required that that indent just one and then of course you can use control structures just like you can anywhere else um in in your code as well so here um we're using our old Fibonacci Sequence generator um defining a function called FIB which I'll show you how to call that in just a bit um passing an argument n which is a variable uh that that can be used only in the function um uh it's a way to pass information into a function we'll see how to get things back out in a second and then um we're taking a and b uh these are local variables these only exist inside the function here um and we're assigning them zero and one just like we did before running our while loop printing a updating A and B uh by the rules of the Fibonacci sequence and then um we have a print statement here that actually doesn't need to do anything this is here to print on a new line uh so basically we're doing to print statements this one's printing the the V the um the uh the uh the the VAR the the first variable and then we're printing a new line with this print statement um if you'll see so uh in Python notebooks you'll see me do this or or hit control enter a lot this runs the code um I'll show you what happens if you try to call a function this is how you call functions you basically call its name and whatever number you want it to put in there um if I call it let me go ahead and close this just for a sec um because I want to show you what happens when you call a function without defining it keep in mind oh wait wrong wrong screen um so if I if I come down here and just run it oh hold on one sec let me let me restart this kernel um how do I I'm trying to remember how to restart these things yeah restart there we go that's what I want um the reason that worked is because I had previously run this when I was writing it but you'll see here if I run this now you'll get a name eror it's basically saying this name remember when I was talking about name spaces is not defined basically it doesn't know what FIB is at this point and that's because I didn't run this code first um in a script that doesn't matter as long as your code your your your definition comes before this then it's defined but here I'll go ahead and run it um like so and now I will run this and we'll see that we get the Fibonacci sequence for everything before for um before the the number 2000 which is the point of this now if I want to edit this you'll see here if I change this let's say we get rid of the print statement excuse me one second you'll see that this does not change this still does the same thing right I'm just rerunning it you I can clear this output by the way uh but with these dots here um if I run it here you'll see that we have still have that new line character in here it's only when I rerun this this it redefines so when I rerun the definition then I rerun this then you'll see it it behaves different differently um so basically you need to run your function code to load it into memory and that's what this defa command does at its chord and we'll break that down a little bit more in the next video um and then when we run it um then uh it will execute the code in that block uh doing whatever we tell it to do um so uh that that's just kind of the the first shot shot of this thing we'll move on to the anatomy of a function and um and talk about its memory usage in just a bit