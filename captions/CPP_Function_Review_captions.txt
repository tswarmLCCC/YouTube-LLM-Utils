hello I have some supplementary material uh today um to really I hope review I hope it's a review anyway uh functions uh in C++ um and and kind of how they're you know they can be useful to start to build out um uh programs that are more readable and more maintainable and things like that um right now uh this is a kind of a supplementary unit in in our course um I'm tucking it away uh in in the current version at least in another unit um that uh I can't even remember what it's covering but um I think it has to do with external libraries but I kind of realized that at least some of us uh may may not have um come to appreciate uh how functions can make our lives a lot easier they're just a fundamental piece of computer programming I really just want to take a go through a brief slide deck here and a few examples um to hopefully make you think a little bit about how you might uh move some code around and and make your your life a little bit easier as as as we get into more complex projects here so um there's no assignment or anything like this uh associated with this unit uh right now as I as I have it programmed into the course um there's a reading unit that's due the same week on functions um hopefully like I said it's review and not and not something that's brand new but if it is brand new and you have questions certainly let me know that's what I'm here for uh but if it's not uh I hope it's a very quick unit uh that that just helps resolidify things and we're revisiting it and kind of um adding it in a new context uh from what you may have been introduced to it in earlier in earlier courses at least I hope that's true uh so I'm going to go and start the slideshow um but again there's no assignment or anything like that other than the reading there will be a graded reading um and don't even think I have a discussion item I think it's tied to the other unit uh for this so um let's see here uh you might recall that we have a bunch of other tools in our in our toolkit especially if you've taken any of my classes I kind of teach it this way and right now I'm kind of discussing in this in the same context as Frameworks and libraries uh but really I want to talk about arguments in functions and return values and functions as well this as well as this idea of kind of uh moving logic that's repeated into one place to maintain it and reusing it um but we can use basically all of our tools that we've covered so far variables uh IO uh Boolean Expressions especially Boolean Expressions uh loops and arrays um and things like list and things like that if we're you know coming from python environment um in functions so you can think of functions is a little bit of a program um that uh lives within a bigger program um it's a great way to think about it and I've got a couple diagrams here but the the big ideas that I want you to think about are separating our programming logic from the inputs and outputs um often we'll have basically two things going on in a in in a lot of programs we'll have input and output or data sometimes uh sometimes our input and output will be from a user like via keyboard we've done that a lot so far this year um or it'll be coming from a file or even like a database right so think of that as the thing that we're affecting that we're using our program on and our program then is a set of instructions that does something right um the something can be very simple it could be like adding a bunch of those numbers up or it could be very complex where it does all kinds of different operations and has menus and things like that depending on on the needs of the program but then when we have a complex program like that sometimes we can take some of those tasks and make little programs out of them that uh we can test in dependently and then come back and use them in our bigger program and this has a lot of upside uh it'll make it more readable it'll make it easier to understand for you and design and make it uh so you can test those functions or those little programs uh by themselves so it's kind of what I'm hting at here if you want to take the time to read read a little text about the thing as I wrote it uh for you know some of the earlier classes um you know really sometimes uh this is my my silly workbench in my in my garage this is actually my table saw but you can see I've got several different saws here right and sometimes we want to uh build our program around our our data um and sometimes we want to bring our data to our program depending on the needs uh very often you know we put our our logic right in our program where we're kind of um you know it's it's more like the table saw where I bring all this stuff to the table saw and um and and you know kind of run it once and then I'm done right it's a big Big Tool uh and I write this very complex you know thing that does something with very little input uh might be just like a board in our example but conversely I've got these other smaller saws here where I might be able to use those like out on my deck or out in a tree where I take a similar tool that's smaller and well understood and use it in a different situation so um you know it was an excuse over a winter break to take a picture of my my table saw and I thought I'd reuse it kind of a fun fun silly thing but the analogy is a good one right sometimes we want big tools that we use in one place and it's very designed to attask or sometimes we want to build um we we want to build tools that we can reuse in U many useful smaller ways um or and sometimes we put these things together and use them in conjunction right um let's see what a second yep so really uh if you're writing similar code a great time to think about functions is if you write it more than once think very similar code think about uh moving it into a function um it's probably the biggest thing I can leave you with if nothing else if you're writing like a print statement or a computation that's kind of the same or exactly the same more than once move it to a function and pass your data to it right um and when you're doing that you can think up is this similar and maybe I can make a function that's a little bit Dynamic that behaves differently on very similar things those are great examples and if not maybe you make more than one function where they work in conjunction but that that comes with time I'm not going to try to beat that to too much be beat that down into you too much um but the other thing about that is as you build things into functions you can test those functions independently right you can even write a a second little program um you know in in this unit the the one I'm I'm enhancing with this um we're reflecting on how we build you know external files and things like that well you can put functions into external files and then you can bring them into any program so if you've got like five different programs that all need a greeting for example to a bank say you work for a bank and there's one that like you know is your user uh it's a maybe something that the on a web page that a user sees you could have that greeting there that says hey this is trev's National Bank Welcome to our bank um and then if you got one for your teller that says you know the same thing um or very something very similar you can write these a function and bring it into all these different applications where you might have a hundred different programs that all just say welcome to trev's National Bank right well if you change the name to you know uh Mr swarm's you know Second National Bank you only have to change it in one place and you could update it everywhere um great use for that uh and things like that um and then of course you could test these things so say you had something where you needed to do compound interest um and maybe uh the way that's done is changing on occasion but you need to use it in a lot of places where you could maintain just that one little beta code and use it in multiple multiple programs just by importing your file bringing that one file name in when you write it then if you uh need to update it later you only have to maintain your shared file you don't have to maintain all the other programs um much like the tool analogy where we maybe have a program where we um you know take something in and do something with it and then do output we can have a function that instead of user input or data we can pass what are called arguments excuse me I'm getting a little dry here we can uh we can take a function and pass arguments to it and either get side effects or or an output in this case um uh uh and and do something with those as well so you can U really think of of again functions as little itty bitty programs that either do things like printing or Graphics right or they return something and we can use it in a more in a more robust manner um both are very useful and we'll see examples of both just in a second here um so I want to just again I hope this is all review and I'm sorry if this is a little pedantic but um I want to go over two main things that happen in functions the first is uh this one in C++ is a void function which doesn't do anything this is called a side effect right where this is basically just going to print the number we give it plus five so here we're giving it a number the input is is past is what's called an argument to the function it's an argument when we're passing it to the function here um and then it's called a parameter when we we use it uh in in in in code so here we're basically giving a little program that says take whatever ever number I give you and print out something in this case it's the number plus five um uh and uh we can use that uh just by doing add five so this would just print out 47 and say uh just 47 when it would spit that out right the other kind of function are return value functions where um so to to contrast these things here we have int instead of void this is telling me that it will give me a number back right so void doesn't give me anything back um but it uh it will instead um just this is a side effect but when we use integer uh is a is a is a leading uh operator in a function it tells me I'm going to expect a number back um so in this case it takes a number again an integer number just like our other one did takes an integer number as its parameter but in this case it returns something right so this is saying I'm going to give you something back back and in this case it's just the number times two for obvious reasons um and then when I call that I have a result here that could be declared in another place it doesn't have to be declared here but the big difference here is here when I call this function um and I give it a parameter it's going to give me something back and in this case I'm assigning that to a variable you'll notice we didn't do that here in this one this one just was called because it's printing it so we'll print that to the screen but this one is actually putting it into a variable we could also print it instead or do other things with it we could call it within another function and you can pass these things to each other and things like that which is very handy and we'll see an example of that when I get to the code but the the main thing is that you're getting something back and you can do something with it and in this case this is a very simple program we could easily put you know 10 * two it's actually be shorter but if this was you know tens of lines of codes or hundreds of lines of code it'd be much simpler to call this thing multiply by two instead of you know all of the code that would would go into that like compound interest or something to that end um so those are the the biggies uh I'm sorry I'm getting into some python some old slides there that I used as the basis of this deck but uh th those are the big things I really wanted to hit in the slide deck I'm going to go into just a few examples here and I'm not going to this is I'm going to wrap this up very quickly here um but let's start with um a very simple idea of repetition right so let's say we have a program that like this a C++ program that does very simple computations so we're just going through here and we create three variables a b and c and then we create space for the three results of our computations that we'll see in just a sec so here we're raising something to the power of we're raising a to the power of B uh right uh uh or times I'm sorry we're raising uh we're multiplying a times B raised to the power of two plus the square root of C so you know just a kind of an abstract thing we're using the math library for some of this by the way that's where we get po and square root from um but uh and then we just print it out so I'll go and run this real quick and we'll see that the numbers are pretty boring uh just simple computations 20 246 and 211 using different numbers right that go into this thing mainly driving that is this power function where it's you know really multiplying something by a lot um but we can see here th this works just fine and it's great for simple math but say we had hundreds of these right we might want to do something a little bit more where uh because you know we might do something like accidentally put a minus here right something to that end or accidentally fat finger this and go like eight you know where it could cause a lot of problems as we copy and paste this function well or or this math and you can kind of see where I'm going with this where what we might want to do instead is um build functions for this and move that into a a a new function called calculate result and you can see just between these how that kind of cleans up our code and so instead of doing this on every line uh every time we need it we only really program that once right and then we call it in multiple places so we can test this using stuff we know um and then and then call it in ways so here we're just basically giving it new giving these things new new values and and printing the result uh in a very similar way that we did before um it but instead of doing all this complex math each time we're just calling calculate result here and in this case we're not even storing it as a little we could store this in a variable we could store it in a variable called result just like we did before but in this case we can actually just print it so it is returning something right it's giving us back the the the the uh the the um the value that results from this expression being evaluated um and we know that that's a double because we tell it that's what we want and as a matter of fact this is another built-in nice little feature that if it's not a double somehow like you put a in here it's going to blow up and say Hey you told me you wanted a double but you gave me stuff that I can't build into make a double Precision floating Point um so uh it will actually give you errors at that point Point um uh Hey Jasmine can you close my door thanks sorry I didn't realize anybody's here um the uh so anyway sorry I I started this conver uh this video with nobody out there and left my door open um but the idea though is that we get a double back and we're promising the user so we're improving our code by making promises to oursel that said this is going to be a double a double Precision floating Point that's that's if if you're it's a decimal basically a very high Precision decimal um uh we're saying it will always be that and you can expect that kind of thing so you can do operations on that as we know in C++ that matters quite a bit um uh and uh it will give us an error much earlier if we get things like letters in there and we can fix it before it becomes a real headache to deal with and figure out what it is um and you might notice uh in this code that there's another thing that repeats a lot right we kind of do the same printing over and over again these are very similar things well I could start to think about this and say hey this is pretty repetitive too well maybe I could do something with the printing and maybe make a void function like we saw and say okay what changes each time what do I need to change to print this out well I see two things I need to need need to that that would change the first is this number right this number is going to change depending on what these are so so I need to pass that in to a function so I'd basically say okay I need to write something that takes a double as a string because again we're returning a double so I I I'd say Okay I I could take this out and pass this in to a new function and that would take this places take the place of this in the print and then the other thing is I might want a message to a com to go with it right because this changes one two and three so that might look something like this this kind of function where I write exactly that where I've got a string where the message goes there so that looks it uh let me close all but these two just let me close uh close a few of these uh just to clean this up so I can swap back and forth so you might recall you know we had this this message here well now we can just say hey I'm going to give you a message spit that out and then spit the result out a double and then we can use it like this where we print result and we say here's your message message and then we actually called this function that again gives us back a double and it plugs it into this function so again we don't have to do result like we did here um uh we we just plug it in and that goes to our print function then and prints the result and we can see here that that works really nicely um and we make our code much more readable and maintain so if we wanted to tra change the message to include maybe some else like like just the word hello we only have to do that in one place here right don't know why we'd want to do this but the point is we can right so if I save this and run it we're going to quickly see the whole thing update um where we get three new uh strings that are tacked onto this thing and maintain that uh in a little different way where in here we would have had to do this in three different places right so uh just a little bit about abstraction there and I hope that maybe res resonated where you know you might be able to do some of this work where you um where you start to to tuck these things away and test so these uh these things can both be uh built separately and then tested separately quite nicely right like we could just give this a message and a double uh to test this independently without even doing the calculation um which is a huge has H upside in its own right the other thing I just want to supplement what we're talking about with libraries and external libraries in C++ with just a little slightly different thing where we might be uh we might want to see uh you know a lot of these functions and and the reason we use functions a lot is to build upon what what's been done before it's kind of like uh that that old saying you know stand on the shoulders of giants right where you don't always have to start programming from the very ground up um and that's this idea of encapsulation and a little abstraction but really we're building upon things and we really see this with uh see uh with object ored programming too don't we where we build things up as we go um and build more and more complex Things based on things that we've built and Trust um so this uh this might be something let's say you wanted to write something that does this so this this is a very uh did I break something I think it did oh I think I was just running the earlier program no there's a problem with this what I do oh I'm using a a different compiler okay well I won't give an example of running this um but uh the idea is that we're taking um a string in this case and inputting it and it just it flips it so you do this by going through and looping through the length of the name uh the string in this case and as I'm doing that uh basically uh what I'm doing is going out to the other side and grabbing it so the length I'm grabbing when I'm at I I go out and I grab the length minus I minus one to offset the zero and say give me that so if my name's Trevor uh the first one the the the thing position zero would be T and then this would be uh the length which would be 6 - I which is 0 - 1 position five that would give me the r and I would basically return that eventually or print it out right um it's just a way to flip an array in C++ but it turns out that somebody's kind of done this kind of stuff for us where uh I can go through and just grab the uh the string um library from from our from from C++ and I think this one will run nope it won't either I'm sorry sorry I'm just using the wrong compiler this is uh different compilers give you different things uh that you can use with them I wrote this at home last night uh but the idea is that we can go out to the string Library um and it will reverse the thing for us uh it's just something that's built in so if I had to do this a lot I don't even have to write it because somebody else wrote it for me and I can just bring it in not have to think about it and trust it now in this case it wasn't a good idea to trust it was was it because um this is something that that runs on some certain versions of C++ but not others but the point kind of remains where instead of doing like this kind of stuff from scratch um sorry the reversal one this kind of stuff from scratch all of this logic I can go out and see if somebody's done it and just include their program either as a function that I bring into my own program or a library if they've got it and we've been kind of living in this world anyway haven't we we've been using IO stream since the beginning well guess what that does all it does is go out and say hey I am going to go out and deal with all the nitty-gritty details of people using a keyboard and a mouse right or mainly a keyboard in our case to to deal with this thing called the terminal down here and figure out how to capture input with you know whatever I need to do on the hardware to do that or to print things out to a screen somebody did that for us and we're just living on top of that well we can do the same thing as we build things up um so that's kind of all I I just wanted to give a little bit of a refresher on um you know keep building your programs up make them make small things that you understand tuck them away really get familiar with return values right if if you can make a complex thing do something very simple and return something that you need later consider a a function even if you only use it once that's a great example because it makes it shorter right um say we got like you know a multi-line computation or print thing like our menu systems are a great example of that our menu systems are very complex but we call them often right where we we' like hey input a number or hey push one to insert a new item two to uh sort the thing and three to print out all the items right well we might call that several times throughout our program depending on what we're doing tuck that into a function and just say hey print the thing and then read it or even just read it and you could have the thing printed and return the number of what they do and then you could do different things Bas on that all kinds of great examples of of that stuff so anyway I don't want this video to be long at all um I just wanted to kind of give a lecture that I've given a few times to some of our C++ students and and tuck it away for for everybody to benefit from if you haven't been coming to office hours uh because I think it's a great thing to rehash um and something that you can all build on so thank you for that let me know if you have any questions on this and I hope you keep keep doing great work in the course um I'm very pleased with everything I've seen I just want to keep supplementing and try try to help as much as I can from where I think we're at thanks bye