okay I kind of want to kind of end or start to end where we started um which is the whole point of all of this uh this idea of objectoriented programming I've spent three videos or two and a half anyway kind of describing how we build these things but I I want to go back to why we build them right the the idea is that we we we we want to think about our program and and I I like the word Model A lot now don't get me wrong I come from a statistical background um and a data science background so I I use this term Model A lot but you can think of a model as an as a a a simplification of what goes on in reality and the idea is that when we build programs we want to simplify what's going on in the very very complex Real World um back to a point where we can represent enough of it to do work with a computer that that's kind of it I'm going to say it again slower we want to represent enough of reality uh so we can do work with a computer in a responsible way where it represents enough of it where it's useful but it only represents um enough of it where it's not so complex that we would overwhelm ourselves um you know we're not you know trying to build the Matrix here or anything like that um but on the other hand uh uh we want to build um you know kind of this model of reality in a computer um that allows us to do do work and solve real world problems with the computer using basically ones and zeros at the end of the day so we use object-oriented programming to do that and hopefully by now you're starting to get a good sense of how we might use some of the technical bells and whistles we've talked about for almost an hour now um to start to build these things up in in in peace wise manners right um and and I want to come back to the kind of a great quote I found from the book creating a program you know it might be it might start from a program and deciding what things exist in the world or in this model and what each one contains and does well what what it contains might that that gives rise to our variables right that's exactly what it does now it might not be a simple variable you know it might be like a town contains people and a PE a person uh contains you know a gender a name and an age or something to that end right where you might have to go multiple layers of objects uh but you you can always go back right you can always just keep describing so in this case let's say let's say we're modeling all of the all of the C all the cities in the country right well at that level it might be a vector of all of these things called cities right and a city might contain people and houses and businesses well each one of those might be their own class and then you could break each one of those down where a CL you know a business might have a name and a address and uh a house might have an address um and a number of people that live in it or or a list of people or a vector of people and then people might have a name and an age and a gender or something to that and where you can keep going backwards and break these things down to where you basically get to to words um and numbers which we know how to deal with very well by now right um and then the other the other side of that is is you know not only what the thing contains but what that what do they do well this gives rise to methods and much like uh you know what how we just talked about with um you know with breaking down you know data into you know very simple parts we can do the same thing with methods where at the end of the day we just talk about getting and setting things and then maybe doing some operations on those on those variables at at the end of the day but really it doesn't come down to much more than simple math using if statement and Loops functions and things like that all things we've studied we've got all the building blocks to build almost anything we want now it's all about designing using those so going all the way back there's a reason that I I use this slide in almost all of my programming classes these are the building blocks or the tools that uh that you know we use variables all of these things but we can basically use functions and then objects and classes that contain all of this stuff variables and all of the these methodologies to basically encapsulate or to abstract away the details of these things to where we're we're Computing at a very high level where we're building things on top of things on top of things on top of things and testing one each one individually um and and making sure they work like we want sorry I'm going through my slides quite quickly here um and and building these things out so this this diagram here in purple this is a a a diagramming methodology called uml Universal markup language and you can see where we start to describe things here this is from your book by the way hopefully it looks familiar um where you know we've got you know in the black the the um the you know the kind of the uh the public side of things and then in the uh in the purple there we've got you know maybe the the the private side of things the the private members um as we talked about earlier um very often you'll start to break these things up into different files the reason we break these things up into different files might uh not be immediately apparent though the main idea though is that you can use these things in multiple programs right so if we've got a program that um that uh uh you know has everything in one file maybe it's uh maybe it's our counting program that example earlier well we could certainly you know create a uh you know a class of people and cities and all that all that stuff all within one file um and and do the counting and be done with it or we could put these this idea of building the objects and classes um and definitions and all that in a separate file and then if we ever wanted to do other work on cities and and people and uh and businesses um from our earlier example we could just bring in that header file um and and do a different kind of program on it so you get multiple shots using the same logic and and you're really promoting code reuse this this is how modern software is built we built things once and we reuse it in a lot of different ways I'm looking at my screen right now and I see five different Windows well each one of those windows is is a different kind of object um that was implemented slightly differently but they all store the same things um you know behind the scenes they all store their position on my screen and how to draw text and how to draw images and even my stupid little mug shot over over here right they all know how to all know how to do that and the reason is they that code was built once tucked away and then reused um you know uh this is certainly this this uh OBS Studio this recording software I use is certainly not the only software in the world that will take my web camera up here and take a picture of me and put it on the thing right that's done somewhere else and reused this is just bringing in the functionality and that's why we can use multiple files to do that ex same kind of work um so the way we do that is we uh we create a header file which again does not usually contain the implementation code but just the definition including the members so it contains the class definitions but not necessarily and signatures of these things and then in the actual uh in the class name. CPP file that's where we actually build the functions that do the work um and the reason we do that is again what we talked about earlier sometimes the header file is more like a promise a promise of what will be there and then the CPP file is what we end end up compiling so the header file gets that gets included in into the into the CPP file that uses it certainly um that that that is very true and this gets into this idea of linking that we'll we'll practice in this chapter um in that section um but uh the uh the the implementation is separated and that allows other people to work on it right um just like we talked about earlier let's see so one last thing that I want to talk about and I think I've got two no just one one example of it is this idea of unit testing a unit test um is basically and we talked about this with functions it's basically setting up a special program a special main program that will take all of your logic and all of your class definitions and all your functions and things like that and set up use cases that you know exist in the world and running them through it um the idea is that you're not getting into a really complex program um uh you're testing these things individually uh and uh and running through a program that will fail um quickly and very uh obviously when things aren't going right so if you have't the idea is like let's say I got a simple function that says add two numbers right and it takes number one and number two and I could write a program that says I'm going to give you number one set to two and number two two set to three and you better return five and if you don't you're going to blow up the idea there is that if somebody messed up how to add those two numbers uh we we'd catch it very early on as opposed to you know buried in logs or in a very complex program um regression testing takes us a little bit further where it kind of builds U upon kind of your knowledge of what's gone right and wrong historically and and test all of these things in one file so when you make changes you run your regression test and make sure everything passes so um if you've got functions and classes that start to depend on each other and chain together this gives you a quick way to say did I break anything I highly recommend investigating this part of the book and and using this this sort of testing I might even make some assignments I haven't made the assignments for object ENT programming yet um but I I might make some uh some uh assignments to that end where we uh where we do a little of this it's it's a great practice to be in and I couldn't recommend it more uh I I can't recommend it enough uh one last thing yep just the very last slide um you can overload uh operators you can think um so what do I mean by operators operators are like the plus sign the minus sign greater than less than things like that um and this is a very very handy trick um so in this case um you use this operator function well if you think about I'm trying to going to try to do a lot in a little bit of time but spend some time with this code and and certainly that part of the book um the idea is that when we have two numbers we could say you know number one you know we might have a variable called number one is set to two and VAR and number two is set to three we can do the uh less than operator in this case and say is to is number one less than number two and in this case it would be true right well we can do the same thing with objects the difference is that we uh we we basically have to tell it what part um you know private or public variables um uh um how we do that comparison because there's multiple ones of them usually right um so in this case you know we're uh and you use this operator keyword and you could use plus minus all of these things and basically what what it's doing uh in this case is a Boolean one and that's why it returns Bole but you could do the same thing with numbers or things like that where you'd add them um there's a lot of ways you can do that you can even uh make new objects from other objects and adding them but that's beside the point but a very cool use case is this one right in front of you where we take two of so this would be in an employee class we we basically tell it how do I compare two employees and we basically say if this ID is less than ID you know so on and so forth you can read it um and it goes just through this so if there's no idea if these are equal it goes to the names and then the section name and all the things but it it Compares these things well the idea then is if you gave it a whole bunch of these things you could actually use a built-in sort function um using this syntax um and again this is covered in your book we've seen it before I think but if not um I just wanted to tack it in here is something that's very very useful is the ability to compare uh objects of of a class and then use built-in sorting so this will use um because we got a whole bunch of these things um these these employees uh we and we have a way to compare them to say which one is greater than or less than the other then when we sort them it will actually use this operator to um to to to be able to sort them and you'll get them in order and the Ord defined by which one comes be before the other one in this case um hopefully that makes sense it's kind of a complex use case but it's very useful very very useful um and uh it's one you might see in your 2030 class um if if uh if you if you continue down the path we do we do that poker hand evaluation um if you might have already done it in 2409 uh but we do that again and this is how you sort these things to do things like uh Straits and things like that as we as we saw um little bit harder to do in C++ but this is a great way to to implement that so okay I jammed a lot into a lot of lecture here this is a big topic though I wanted to reinforce some key things I saw from the book and it took me an hour to do it I apologize for that um kind of um but these are are shorter videos so hopefully you can go back um and and review these in the book and please please please ask questions functions and object-oriented programming are the thing we've been building up to the whole class um this is a big jump forward uh and it's basically the technical groundwork has now been laid for everything else you want to do in programming um you've got all the tools now everything else is just understanding that some of this has been built for you and that you can build your own on top of those so anyway that's all I have uh on this uh for this week um let me know if you have any questions thank you