hello this video is going to be part of a larger series a whole unit probably a two- we unit actually um on organizing code uh our our directory structure unit testing and documentation um I've created a a couple different uh GitHub uh repositories for us that kind of you know give us a boilerplate um uh you know structure uh that that you guys can use for sure but I wanted to take a a bit of a a a step back and describe what each of these things do and then um take a little bit of time uh to to um go over what uh one thing we probably skipped which is compiling and make files um but more on that in just a second starting out um a lot of people um myself included will just fire up VSS code or whatever code editor I'm uh using that day uh it can be you know certainly GitHub classrooms code spaces now or repet before that um and uh go ahead and just write something in the directory you know just right here and and go ahead and fire it off uh you know much like this and then you know use this old button right we we fire this off it does all this weird stuff that we've never quite understood kind of does it once and then we've kind of learned to go to output and kind of see things there and go to terminal and see oh there's our output right we've kind of learned how to do that but what the heck's going on here is a great question a great one indeed um so we're going to go over that a little bit um uh if if and you probably have seen either main. out a.out or things like that pop up in your directories as well um when you when you when you hit that hit that play button we've been calling it right in in a C++ so going to delete that for just a sec and we'll go back to that main program here like so um and say we've got a program like this right like I said we you can kind of hit this and go what this is actually doing is running the active C+ plus file um it's so it's a handy thing for people to get started with but it quickly doesn't it doesn't scale quite well you may have run into this same problem in repet um and you probably have seen uh some of my videos where I talked about um where you have to go to the Shell and compile uh to to run more than one main program um well the reason for that is because that play button in repet actually is is using what's called a make file and it's looking for something called Main CPP um just like this but you don't have to do that as a matter of fact most C++ programmers don't you can use um what's called a compiler to basically build your your program uh from source code into what's called a binary file that's machine readable code if you go all the way back to cc1010 or or or you know another class you may have taken uh that's machine ready code that's U not very readable but uh it's something a machine could understand so to do that um most uh modern uh or I shouldn't say modern but the the uh both repet um vs code I'm sorry repet GitHub GitHub classrooms and and what I use for vs code and what I have referenced in the shell under getting started is the g++ compiler it's part of a huge Suite um and it includes make files as well uh and what it does is basically takes text in this case our source file all of this text and it says oh I know how to interpret this and build a binary so what you do is you give it the name of your program so you'll notice I'm in this uh GH here and that there's a source directory here um U and I'll come back to why that SRC so I need to go and look in SRC and that's all I'm doing there right and then typing main.cpp and you'll see here when I I'm going to open that back up is when I do that it will actually create an executable file right there in in the directory I'm in and it's called a.exe um if I go there if I actually run that now it will actually say hey here's the template main program that's exactly what I wanted that to do right kind of cool right so I'm going to go and delete that I just want to clean up there so um now the reason I put this in a subdirectory SRC is to keep all my files in one place um and I'm going to take a step back at this point and kind of go over what all of these directories are for um and we'll we'll we'll touch on some of these other units here uh but the main ones um are the source directory an include directory which actually has something to do with coding as well it's how you can kind of Link files and make some promises to yourself and things like that in C++ beyond the scope of this video um and then a tests directory uh we'll come back to this um but basically there's uh we're going to also cover some te testing of our software using unit testing um so a common directory for that is tests um it's not necessarily related to the functionality of our program itself uh but the tests are certainly programs in their own right uh so you might want to separate those right and then lastly or not lastly a documentation folder and a binary folder bin and Doc respectively um the uh doc folder is uh is meant to hold documentation this would be you know basically manuals on how to use your software or how to install it or references of different functions and things like that uh for either you or somebody else to come along and build on your work um anything like that goes in there and uh we'll go over that in the documentation video that'll accompany this uh but the main thing is that that's the place for that and then the bin folder is a place for our binary files so you might recall I just made that a.exe file uh when I ran this and I'll go and do it again um but that's kind of you know not where I want it to be oops sorry right let me I I deleted that's why we got that if I run that again we'll get an a.exe um well maybe I want to put that somewhere else so let's actually go over that right now let's go over that right this second let me go ahead and clear clean that up U so I'm going to delete that right see um it turns out that there's another compiler option uh when we go GCC SRC main.cpp I can use the O the output flag here and I can give it a place to go so I can actually say go into the bin folder and I'm going to call you main.exe in this case because I'm on Windows or if I leave that off it will do it for me I think let's let's try that out so if I go into bin here I can see that now I've got a main.exe now to run it of course I need to go in there as well so I go bin and Main and sure enough there we go um so that's how I would run that pretty cool right so I I can tuck that away I can add that to ignore if I want to in GitHub and it won't company so I'm going to clean that up too so that's already a better practice runting something like this right or I'm sorry runting something like that let me go back into my source and I'm kind of getting ahead of myself here uh where I I can keep there um so that that kind of replaces hitting this um but you might think boy it sure gets old you know compiling it every time I do this and then running running it even if I'm using the up arrows to do that that gets a little old um I don't have to delete it all the time luckily um I can just kind of do this so if I if I make a change I could get into like doing something like this if I added exclamation marks here I could get into this where I'm just using oops sorry got to go down here hitting the up arrows to do that if I can get to the right window I can recompile it then rerun it and we'll see we get all those new exclamation marks right um which is cool in its own right but it turns out there's a even a better way to do that um let me clear that out um we can use what are called make files make files are basically sets of instructions and rules um that you can use to uh automate that process for lack of a better term the way we do that is we basically give it what's called a um oh I think they call them targets uh targets or oh no they're called rules so this is the main rule main Rule and you can see that I've got this uh this output file here um that gets created here um so I I can uh I can call what'll be called make main um so this lives in a special file called a make file and you notice I've got two here but the only one that matters is make file and I think it can have both a capital or a lowercase M uh but it needs to be there there in the root directory or in the directory you're using but when I do that I can say make main uh I'm going to go ahead and delete my binary file here just so you can see here um that when I when I run this I don't have to remember that so you can actually copy this and and put that in there and then uh get that but not only that you can actually run it as well so I I could add I could just um actually run that next line right here you'll see that when I run this rule it's going to do both of these things so let's go ahead and do that and you'll see it kicks out this uh but it uh it turns out that's not the best way to do things necessarily uh the best way to do them is to basically make different rules for different things because you can actually use uh the make command for a bunch of different things so I could do something like this where I've got you know the main this is actually what I do to run it and then I could make do something like main. uh CPP make a different rule um where I run the comp compilation so what'll happen here is I can I now I have two options if I take the main CCP Rule and I go make uh main.cpp and let me delete our binary again real quick you'll see that that's what that does so now that I've got that I can make that independently if I want to or if I want to do both let's go ahead and delete that I could also do something like this where I could do main uh Main and that oh and the other thing I need to do is see these can have dependencies so if I put main. CPP here when I call Main it says oh you need to build uh that first this one so that goes there and that's a dependency of main before it will run the main program which is what's going on here so now if I do that um and again I'll I'll delete that I already did if I type mean you'll see both the thing get created and uh what did I do here uh oh I don't think I saved it let's try that again yep there we go so you see there it's making it and then it kicks it out turns out you can even do something like this if you wanted to clean up you can make a clean auto completes doing it for me um but uh I'll show you a more robust one of these so now I can do like a make clean if I don't want to remember how to clean that up and you can see there's nothing in that bin file right now pretty cool right so it's all coming down to the main so the reason I have this old one it's actually not old it's actually the one I want um is I'm going to rename this one something like that and I'm going to use the bigger bigger one and this is the one I Supply to you uh or sorry this one is there's a couple other things you could do to make your life a lot easier um this is a little bit bigger um let me go ahead and drag this down just for a sec um so some of this will look familiar like this and this right uh but it turns out I can make a make all where the dependencies will say okay uh and that's just make by the way uh if if you don't give it one it will run the first thing in there so you'll notice here when I make this I've got a factorial working a main and a test factorial all in here so if I type uh make here it's going to try to build all those and let's go and uh drag that up like so to see what happened there whole bunch of stuff there I got an error which which was actually intended because we're going to use this for unit testing in a bit U but you'll notice in bin here A whole bunch of stuff got made or it started to um that's because uh let's actually use factorial working here because that one actually works um and if I just do make by itself there you'll see that chain of command here uh kind of or chain of dependencies go there and a whole bunch of stuff's going to get made uh and it just goes on so what's happening here is let's see let's start out it comes into all comes into all here and it says okay you need I need main to do this so it goes to main goes do I do I have a rle for main I do that needs main CPP so it goes here and then it runs the compiler and then it runs it we saw that if I didn't want it to run it I could just leave that out of course um and then uh it would it would run it um as well uh without spitting out the text and then the same thing happens with factorial working the other thing and I won't go too much into this here but it's pretty pretty cool in its own right um is that you can use uh you can use uh variables in here so these are all variables you just use either the equal sign or this they're interchangeable as far as I know um there's no strings this is actually a string all of these are strings um but I can say which compiler do I want to use and you use this syntax use this dollar sign and parenthesis Syntax for the command and so I'm all I'm doing here is replacing this with this so I don't have to remember how to type that and you'll see that here in factorial the factorial one uh this one I'm echoing it and then this one I'm actually just using that um but then later you'll see I even put directories in there so I want the the bin directory or I'm sorry I uh the bin directory is here um and uh and and the source director is here so I don't even have to type those like I did here where I have bin here and Source here I can actually start to just replace those in these strings and it turns out I even said hey I don't even want to deal with file names uh so I I created a file name that says factorial working the name of my file and you can see there it's basically just tacking factorial working. CPP on there so all this whole thing is equivalent to uh to this one uh the only difference is that or I'm sorry this one uh the the or no it is the output one it's this one the only difference is that um that I've changed uh some variables in there to replace things like that then of course the clean here is a little different too where it just runs the command to run everything together so super handy right so if you come in and you see a make file take a look at what's in there now it turns out you can write tests and things like that with this too we could do make test or make you know much like clean there's nothing special about the word clean here it's just running a command um but we could take say standard input uh into our C++ program and and expect certain output and things like that and that's that's something we'll talk about in unit test but I wanted to introduce make files first um because uh you just get a lot so just one more time on on how all this you know can work is I'm going to kill that one and this one so I've got this this folder structure here that's pretty pretty basic uh oh one thing I didn't cover with the D structure is a readme file um a readme file is uh as as you probably know from GitHub uh now uh it's a a file that's meant to be read first and it displays quite nicely um you can actually even preview these uh because that this is a programming language called markdown or a markup language called markdown where they have you know special syntax and things like that that's why this looks a little different than that um and I've linked to that in the module in the module for the this unit uh there's a a guide on on markdown and how to make these look prettier uh but this is another source of documentation so um your your starting point of your documentation would go in your readme file this markdown file um everything else would go in Doc here and I haven't created anything in Doc we'll go over that in a bit so uh but anyway just to just kind of sum that up closing everything here uh you know we go back to our main file got a make make file here um you know uh we we've got this nice thing and once we have this set up we don't have to think about it anymore right you might want to add new ones if you have different main files or you can actually have it build everything that's a C++ file um I I've given a couple guides on that um in in the in the Shell uh so refer to that but there's a lot you can do with these things they're very powerful um and you can hopefully see already how they're they'd make your life easier and we can kind of get away from the headache that is this thing and get a lot more control over what we're doing so once again uh make by itself if it's got it'll execute the first thing and in this case it's going to try to build a whole bunch of things uh or if I just want one thing at a time make Main and and Main here again is just a rule it's just targeting this and then saying oh I need main CPP and it's running the compilation so it's kind of backwards basically uh it'll do the last thing first um uh it'll do the last thing first that it needs to do uh so it the way to read this is okay I need this so this is the first thing that's going to get run um because this has no dependencies if this had a dependency out here it would go run that instead it'd go run that rule um is how how that works but basically this changed to nothing because there's no dependency this one changed to this because it is a dependency of Main and that's the one I called but I could call I could call uh make main.cpp or I'm sorry underscore CPP by itself just like I did demonstrated earlier is nothing keeping me from doing that the nice thing about this though is that you can chain them and really automate your work uh which is pretty dang slick so uh the main thing that to remember is you need to be in the directory of the make file when you run this and um if you use relative pads like this that they should reference here so I'm in the root here and I've got the bin so that's one off uh just make sure you're in the right place for this uh and it works just fine in GitHub classrooms and code spaces as well so um I think I'm going to button that up hopefully uh I've inspired you to clean up your workspace a little bit um and uh in the in the notes and in the in this week's homework uh there's going to be an assignment to basically use this structure um and start to document your code and a few other things lots of tools coming this week but this is the first one and there's a few more to come thanks bye