one idea that's kind of central to a lot of of the the things we've studied so far is this idea of expressions and expressions are basically a series of statements that can evaluate um and that's a key word there evaluation basically though what we mean by that is we take Ser a series of things um and break them down into what amounts to one value and then we use that value either as a variable somewhere else or in the case of branching statements and in ter in in next week uh in terms of looping we we use that as a um a true false statement to say should we do this next thing um should should should we proceed and that's an an if then else or uh you know a true false statement usually um true false in most programming languages has a special name it's called Boolean b o l uh um and then Boolean is you know the the uh the um the ad adjective for the type of expression we're talking about and this is as opposed to numeric Expressions numeric Expressions uh evaluate to Nu numeric values you know um uh you we saw that with math you 2 plus 2 equal 4 where 2+ 2 would be an expression and it evaluates to just one value which is four and you can of course chain those it could be 2 plus 2 divid 38 you know time 43r to the^ 3 it's still going to evaluate to one number the same as true with Boolean values they just evaluate with to true and false um and they they have some different operators uh which which allow us to do uh logic in in this case um and I realize let's see where can I put my face you know I'll just hide it and see does that do it yep I'll just hide it for this slide here so you can read the slide while I'm talking about this but um basically we start with this idea of an equality operator um an equality Operator just simply tests if two things are equal um uh you know 2 equaling two or a variable holding the value of two uh would evaluate to true if we used the equality operator otherwise it would be false you know if for example we had a variable called you know my agent it's you know 47 and I I check to see is that equal to three it would evaluate to false um that is a double equal sign um as opposed to the assignment operator uh these are these are different things this is an two so if you're testing for equality in in C++ you use two equal signs like this not just one I'm going to say that again because somebody will always mess it up one of you will mess this up when you first start writing code you're going to you know test age with a single assignment operator and uh and it will it will just keep going because it turns out um you can actually write if you know two things are assigned or if if the assignment operator uh uh passes you know if I wrote for example 2 equals or my age equals 2 with one equal sign it will say that's true because it completed that operation that's what's going on there but it's not checking to see if the values are equal so make sure you use two equal signs there um and we might test that later uh if we get into a code example with that the inequality operator uses this um ex exclamation mark and it's basically saying are these not equal um it's the exact opposite of this these are these are opposite and usually you'll see that with an exclamation mark it means not or opposite of what what the original one is um you could do it with equal signs too or I'm sorry greater than or less than as well you can do things like that um but basically these relational operators check how one value relates to another um you can actually so you can either use these directly so for example I could uh in in these previous statements or even in these examples up here we can see how we're comparing um you know like div reminder equal to the value of three here um remainder sorry not remainer D remainder equals to three you can so this is a constant but it evaluates uh just as a number and it's just comparing it to a variable here um and then we use the double equal sign so in this case if if div remainder was indeed zero coming in um we would basically say this is even um else it's odd right it would one of these two would would uh would execute um you can also store these things in variables so for example we've got a couple different situations at the top of this block where um we're testing to see if current temperature is greater than the desired temperature in this case if the if if the current temperature is higher than that we're storing that true or false value and is hot and then we've got similar ones for is very hot and is humid just depending on different logic we build in and you can just evaluate that straight away or you can start to combine them using our operational operators so this one just says you know if this one evaluated to true then it executes um and this one says if both of these things are true and we talk about that a little bit later where we we're combining these things uh actually it's down here with this and operator um and we'll get into truth tables in the next Slide the idea there is both of these things need to be true because this is an an operator that's opposed to an or operator there's several others but and and or are the big two um and uh what's going on there is both of these have to be true and if both of these are true then it goes in here and we but we fir we simplify our code by first doing the calculations up here and um and then we can also use negation operators like this where we use the not is humid which was derived up here and that's just saying hey if this is true and we're going to have evaluate this part of the expression is false and if this is false we're going to evaluate this is true so that would have to happen uh the second thing this would have to be come in as false and it would get flipped to true and then is hot and basically not as humid for this this to this this part to happen right here um that's something you're going to have to get used to and we'll spend a lot of time this unit uh playing with that kind of code uh that'll be the main thing um these are often useful things to do where you separate your logic and you do the assignment up here this makes your code a little easier to read and also we reuse is hot here don't we we use it twice and we also use this humid twice here so instead of writing all of this twice we can just use variables to start to abstract our code um and put put the calculation in one place and just store it for later use abstraction is this idea of taking an uh taking a bit of logic and doing it right once and then read using it um uh we uh we we start to make our code a lot easier to read and maintain if we do that so for example if if really hot if we needed to change this constant right here we could do it and we still wouldn't need to change anywhere else where it's really hot happens so that that that's a good practice to get into there um and then on the screen you might have been reading through this and it's certainly in your book as well you can see some of the common operators that we have um uh available to us other than uh the the uh equality operator um we start with that certainly um but we could we have you know less than and greater than um and these uh have some examples over here less than or equal to and greater than or equal to are separate than that um and that basically includes the you know uh the equality operator so for example if this is three and this is three this would actually be false where this one down here if this is three and this is three this would actually evaluate to true and the same is true with these other two um we already talked about the negation operator basically flips the true from false and false to True um we can put parentheses around things to make sure they're evaluated first if we start to change these things together we can have certainly more than two we could do you know if it is hot and if it is really hot and if if it's not humid we can chain all three together and start to build uh multiple ones basically what happens there is uh it will do an order of operations and start to condense these things down one at a time and then keep pairing back until it gets to one but it will always come back down to a true or false statement if you do that um and there's an order of operations I think these are actually this is the precedent rules for these things as well so the first thing that happens is parentheses are evaluated then knots and then all of the addition operators um if if for example you're doing some addition before you compare um those will get evaluated before you compare and then um our main comparative operators uh including equal I think equal should be in there uh relation operator should be in there um so equal equal I'm sorry that's next I see um the in the uh equality and inequality operators and then the end and the or um one thing to note and I think I talk about it here is that the end of the or have a a sister uh to them where um so and and or basically say are saying um like for example here uh uh well let's let's do that and then I'm going to come back to what I was about say which are the bitwise bitwise operators um these are called Truth tables um is what um and they're used in evaluation basically um in a in an and statement both things need to be true for the statement to evaluate true is how to read that um this and this must be true otherwise everything's going to be false so if you have two falses it's going to be false or a false in either position it's going to be false the opposite is true almost with the or statement basically if there's a true anywhere here here or here then the thing will evaluate to True um the only time an or statement will evaluate to false is if both are falses this can get very confusing but as long as you break them down pairwise with each one individually you can can always trace your variables and figure out why things are happening the way they are but if there's a lot of these things going together then um sometimes it can be quite confusing and and worth maybe printing out your variables or using a a debugger uh to go in and look and see what the heck's going on uh with your variables if if something's behaving a little bit weirder than you think it would be too um the and then the other thing I wanted to add here is this idea of bitwise operators um You Might Recall from week one when we talked about binary operators um the same things are true with these but the uh the single the single and uh um I'm sorry excuse me the single uh the single pipe and the single and they represent bitwise operators as opposed to the doubles you always I shouldn't say always you almost always want to use the double and and the double uh pipe for and and or respectively the single and Compares each one and each zero uh in in a in a binary string to see if if both are flipped or both are Set uh as a and likewise with or uh you get the same thing there those are used a lot in like networking and things like that or signal processing sometimes Graphics they're very fast operations because they work on those individual one and zero level levels and frankly everything does get broke down to that level if eventually but those are usually not what you want especially as a beginning programmer um the the only thing I also wanted to call out that you'll read in the book is this idea of short short circuit evaluation and it's basically saying kind of what I was alluding to earlier um basically uh if if then lse statements will stop as soon as they can um uh for example in our and statement as we can see here if we see false anywhere if we see false anywhere the whole thing's going to be false we just know that um because we've studied this stuff and and and certainly computer scientists smarter than us have studied this stuff um the only time that you know basically everything's true is if both are true right so the first time it sees a false in a in a in a series of and statements it will just say hey that's false even if there's 15 of them combined the first time it sees false it knows the whole thing's going to be false so it'll stop early um there's nothing wrong with that it will evaluate just like you would expect to just be aware that that happens so um I think that's everything there oh one other thing um that floating points should not be compared using equality operators the the level of precision can throw that off so if I have 2.3 and 2.3 00000000000000 one those are not equal um and usually use uh greater than in equal signs and ranges which are covered extensively in your book there's many examples there there to kind of do that kind of work to make sure that's what you're wanting to do um the last thing is if you're comparing strings you can certainly do all of these operations on strings but be aware that that the case the uppercase and lower case matter a lot with strings um speaking of strings we're going to jump into that uh a little bit here oh I got one more thing sorry I want to make sure this is the last yep okay sorry let me go back to the last one there that we just talked about uh nesting um the execution block is something to be aware of um that you can put anything in there so um if you uh if you need to you know kind of build end statements uh another way to build them is to say uh if you needed them to be different depending on you know your logic you can certainly do that you could put anything in this conditional block including other if statements or in the future loops and functions so if you need to make sure that somebody has three items in their cart um they get a discount then you could do something like this uh depending on the uh total cost else if it's just greater than zero if they've got anything in there they might not get a discount um but you can you can build that kind of chained logic together um or nested logic to as well we'll we'll use that a lot here we'll also use nesting when we come to loops and control structures in a in a very near future unit as well um those are those are two biggies that kind of are that next step for a beginning programmers is to understand that you can break these things down individually and do something like that so um tried to stop this video three slides early I apologize for that uh we have one more little bit uh left um just a followup uh from the uh the the types unit on strings here um that uh but I really wanted to talk about set logic uh or the the the the Lo the Boolean expressions and then the control structure that is most associated with those if statements separately so we've got those two videos um uh and then but the last one will be a little bit different