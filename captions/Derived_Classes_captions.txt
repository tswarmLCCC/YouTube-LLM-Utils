hello and welcome back uh this week is one of our more our more advanced units uh that that we cover in the whole program here at LC actually it's this concept of derived classes or inherited classes um and some some topics that go along with that like polymorphism and things like that um this is an extension of object-oriented programming um that you should have covered both in your first year at the end of your um your intro to computer science class hope Yul and if not certainly we did it earlier as a review in this in this class in 2030 um when we recovered objectoriented programming um objects as you might recall are essentially derived data types data types that I'm sorry I shouldn't use the word derived there uh constructed data types that build upon our our primitive data types like integers and and strings and things like that um it turns out that you can actually use um these these built data types A Class A pre class that we've built and you can build other classes from them um and it turns out this is one of the more powerful techniques in all of computer science and frankly it's how a lot of advanced software ends up being built is that we've just built these things up over time um so got a a quick unit for it just here at the end of the year um not too much in terms of homework but um it's it's a lot conceptually so uh please let me know if any of this is a struggle I'd love to go over any of this with you if if that comes an issue so um just some learning objectives uh that I wrote down here uh there is a zybooks uh unit on this it's called inheritance uh uh I think yeah Unit 10 here and uh just like all the other units we've done uh basically the uh required uh the the the the built-in reading um there's a few examples here that you don't have to do anything with um uh and uh but I did turn off again the uh those challenges uh that we're taking so much time so it shouldn't be too bad there um and uh and then there's going to be a uh uh let me go back to the module for this one sec uh oh actually here it is sorry uh there's the guided learning um oh I haven't renamed this yet actually I have uh I just need to reload it uh way down here now yeah derived classes there we go uh there's an assignment um this one's a bit complex and I'll go over this I'm gonna go into the the code like I always do um but it's a little more in terms of complexity than what we've been doing and then there's a discussion um the discussion is a little different because we do not need to use something like derive classes for the final that we'll be doing probably within a week or two after this starting at least um so this is not about the final like it has been it's just about how would you use this and can you see it's it's worth that's what's going on uh with with the uh weekly work here um let's see I think that's it I've got a bit of a lecture so I'm going to try to bring that up now see oh that worked much better than I was hoping it would um just a few things so hopefully uh please try to read the material before you come to this lecture so if you need to pause read and come back that'd be great um but I I just wanted to highlight a few things um so I'll I'll get right into that um let's see here so Drive classes they're basically a powerful mechanism that allows code to be reused uh we we what what we do is we inherit uh classes from another class so if we got like if we've got a class and we inherit it we get all of the stuff that was in that class for free um and so we can do things like re uh remove code reuse and things like that um and if you can think about these things in a like a hierarchy you can build these things like uh a on each other um so for example if we have an animal class uh it might have you you know like an animal will always have a weight and it might have a name right so those are things we might store in an animal class um we might then build a subsquent class that might be a bird class that is an animal class it is an animal class but we might add things to it like it can fly and it can SHP and things like that um or we can overload things and things like that that we'll talk about in a bit but the idea is that we get everything that happened in the base class for free and then we build upon it as opposed to starting over so instead of building like a dog that would have a height and a weight uh and a name and then a bird that has a height and a height and a weight and a name um and then you know the one might bark and the one might chirp we build animal that has the height the way the name wants and then we derive the rest and just add the little bit that we need at the end um so it makes for much more efficient code and things like that uh let's see here uh oh kind of kind of De this so one thing that's nice uh about these things other than reliability is that um we uh we can make changes in our base uh base uh class and all the updates happen for the the the downstream classes um just like what we've done with functions and a few other things and modules uh as we've studied those uh building you know maintaining things in one place and getting them used in a lot of places is is good stuff right that's that's good things um and then finally polymorphism probably one of the more more uh popular uh or Advanced topics that we'll study um I'll try to describe it quickly with an example but we'll get into a few examples here in the code as well um if if you what we can do is we can basically make a base class that says let's call it a video game right it has a draw a draw method and it says this is let's say we've got a video game character as our base class and it's got a draw method and may maybe it just draws a a box you know it doesn't actually show anything that's useful but it just draws a box by default then what we can do is we can maybe make a a you know a hero guy and an enemy guy and these guys have different images for each of each other as you might imagine would happen in a video game and what happens is when you you can call the base class so it might be video game character uh or you can call both the the hero and the enemy um and you can call their draw methods um by looping through all of the video game characters so because they're inherited from this Base Class they are part of that Base Class um so let's say we've got video game guy or video game character hero and enemy hero and enemy are video game characters and so I can Loop through of a type of video game character like a computer type like a data type of video game character as opposed to each hero and and enemy and I can call it draw method and what it does is it resolves those in the the the Sub sub subclass methods uh automatically for us and it really makes for some powerful code we'll see examples here that's not a very good description but it's hard to do without code um but huge benefit of dried classes there let's see um so the syntax is pretty simple the main thing we do is we use this colon and then we give it the base class so say we had our video game character that would be the Base Class we'd say video public video game or uh the way this reads is Drive class is inherited or is derived from the base class so we might make Class Hero guy is derived from video game character here that's how we start our class thing the public basically says that anything that was in Base Class that was public is also public here there's other control mechanisms that you might use that are appropriate there but that's the general syntax let's see oh let me move my picture always always gets in the way put me up here for now um so another so here's an a better example we might have a uh what we do is another way to do polymorphism is to build what's called a virtual function um so virtual basically uh means this is not actually a real function it's kind of a promise that whatever class is derived from this will implement it um so what you can do here is you can say you know this is virtual and uh this basically says I'm not going to actually implement this so you can't ever actually create a shape by itself but what you can do is you can get all of the stuff that's in shape um in a uh in in the in the derived class and then you can call these as shapes and everything that's derived from it can be called with the same method or the same array you can have array an array of shapes and loop through them and then call each of their draw things which you can imagine is much easier and much much easier to read and maintain and all that than saying you know hero unit hero unit Enemy enemy enemy we can just say Loop through all the shapes um as well uh so that's kind of what's going on with polymorphism there um but again you'll just need to kind of get into this this is this takes a little bit to click for some people and that's okay um but this is kind of what we're getting into and what we're trying to do here uh what else did I do oh here's here's another example of that um so uh let's move my head again I think I can fit down here this time kinda so uh here's a virtual uh virtual function of speak right uh where we don't actually implement minut it but then we inherit from animal so this is the animal class we uh we derive dog from animal and then we do implement it and we use this override function or keyword in the function to say hey this is overriding the virtual function and then we just say when when when a dog speaks it say wolf similarly when a cat speaks it say meow but you'll notice here what we do is uh because the dog and cat are animals they they are animals and they are dog or cat depending on which one so because of that we can make an animal we can make a new dog that is an animal so you see we're calling the The Constructor here and making an object that's a dog but we're we're um we're using it as an animal and you have to use the pointer with this syntax you can go both ways it's usually cleaner to use the the pointer syntax though like this um and then you can see we just call animal one and animal two and the speaks will do the the meow and the Wolf but those weren't even defined up here and that's what polymorphisms power really is um is that you could you and you could keep an array of these uh a vector and just Loop through and say speak speak speak speak speak um and then of course because these our pointers we delete them so that's kind of you know an example of what we're doing here hopefully this illustrates the kind of The Upside but I want to hit it just one more time before I get out of the lecture part of this and into the code the main point is that we're basically able to use an animal type that changes the behavior of its speak function depending on which which subass it's using um which gives us all kinds of power and frankly you could keep building just amazing things with this kind of kind of uh mentality and just the the fact that we're inheriting everything you know think about like this video even like there's something that uh that that was built to say okay how do we how do we encapsulate one one one pixel one one dot on your monitor right well then that was done and probably put in a class somewhere and put away okay how can we turn that into an image then just a whole bunch of those right and maybe some some of different types things like that and then how do we make a video out of that well we we start to put those together and all those were built separately at some point in computer science history and then they just keep getting uh uh enhanced upon it's actually you know different than that but you kind of conceptualize that and then finally YouTube you know they said okay we're going to take the video format and inherit that and now we're going to make it able to stream over the internet right that's that's all kind of things how we build these things up from from scratch very basic things we just keep building and building and building and adding a little more we don't start from scratch every time is kind of the point um and and classes are a great way to do that um the more you study computer science the more you'll start using things like apis or third party libraries where you import stuff you never even see how the things are built um but you just build an object on top of that and you inherit it um you inherit from it I should say and add just a little bit of functionality to the end and it might be as simple as like I'm in I'm bringing up a window uh in an application with a scroll bar and it minimizes and maximizes all that stuff and I just want to make the background red instead so I inherit everything everything else that was done in window windows or the Mac OS for me by a previous programmer and I just say instead of making a basic window I'm inheriting it and I'm changing it to Red that's all I'm doing um and so you get all this power at your fingertips for deck to nothing and you just have to understand that everything works underneath and how do we know what's underneath there well we read documentation don't we or we talk to people or we build it ourselves sometimes um but that's kind of the gist of it and the power of all this okay uh that's a good lot a good bit of theory let's get into a little code here um let's see make sure I'm in the right one yep so I'm I've just got a couple example classes for you um let's see I'm going to start with polymorphism this polymorphism idea um that we just talked about um but we can see here well you know I don't I kind of just went through this actually but this is one you can play with um you can change this you can see what happens uh you know if I change this to dog and cat things like that you can change that and but I guess for the main point right now let's just run this thing like so and it should compile and we get a yeah yeah just one set doing it yeah always does this the first time I run C++ code on this for some reason but we should get a a bark in a meow before too long here or a woofing a meow and certainly we do so basically all of this you know like we were talking about just before all of this uh you know it derives from a a a a an animal class and we see that we are actually creating animals here not not a dog and a cat uh well we are creating a dog and a cat but we're treating them as the animal class now if I made something like this where I did something like this with dog where I made it um walk um something like this uh and I would need to do this oh it's because I override I think need to get rid of that yep so I can make a walk method just a regular you know walking the dog or something like that I can certainly do that right but I cannot call that from animal I can't so I can't do this let's see so dog is the animal one I cannot do this this is going to this is gonna freak out oops not like that I cannot do this as an animal this is not an animal function but I can do this as a dog so if I make a a a new dog an an a dog animal or a dog type I can do this like this if I wanted to let make make it animal 3 I can do this and um let's go and just fire that off real quick hopefully it runs yep uh we can we can do that as a dog but the only reason that worked is because it was a dog animal basically I can call these I can call speak here because I promised I would up here I would have to move walk up here as well uh to um to to be able to use that now if did that I I could do that quite easily right we could do the same thing here just like this let's go ahead and make a walk here and then I need to change this down here to an override just like the other one the uh the dog one so that that that's going to work for everything else and I can even do it use dog the same way but now you see cat's broken and that's because cat did not implement this see this is a virtual function um which means I promise I will do this when I build this so until I make walk for the cat here it's not going to work and we even see an error here when I when I fire this off it's blowing up doing doing all the things when these blow up but until basically I make a walk for cat here it's not going to let me do that because I told it I would when I inherited animal here I basically said I promise I'm going to do this virtual function or I'm sorry this virtual function here so if I change this to walk it will work it will work we'll just do cat walking and everything works again for us um but now we're just inheriting the thing before what happened here why is that freaking out invalid I think that's actually gonna run work when I compile it yep it did I don't know why it's freaking out right here but um so that's kind of how those all play together though please spend some time with what I just said there rewind it if you need to on on how those things interact it's probably I I don't want to just keep saying the same thing but the lesson is is kind of there the main thing is though these when we we build uh virtual functions or even functions in a base class we can call them in sub classes as long as we uh Define the the variable as the base type we can do that but they um and then virtual functions um they if you Pro if you do a virtual function you need to implement it um we could Define these things up here as well where it's just a generic walking one uh and then I wouldn't have to redefine it lower that that's just regular inheritance um just like we we we saw in in the zy books so that's kind of polymorphism in a nutshell um I've got a few predict and run things here for you um uh this one is talking about exactly the same thing we just talked about just calling those out feel free to play with them just like I did um and then the override I call those out here right so in this case we're making a base shape and we're promising a g type a uh perimeter and an area um and so we make sure we um Implement all of those things down here uh uh you know for each of those so we make a a a circle uh in a rectangle um and uh one one other thing is of course to maybe review private and public methods uh as well here and then oh there's three actually there's a triangle too I kind of forgot about the triangle but the point is we're implementing them all here we can make shape right and then we can call we can do all three of these and we can go and say give me the type the area and the perimeter even though we're not calling them as triangle and as Circle and as as uh as rectangle or whatever the the third one sorry but that's the point of of that the investigate one is very similar except here um we're kind of illustrating the investigate of of how those go you know together kind of the same thing again a lot of these are repetitive but you can kind of play with them in different ways really though I just wanted to give you advant uh uh some working code here uh to implement uh for the make unit now the make unit is a little tricky um and it's a little different than what we've done in the past so here the make is actually just a main program but you'll notice it inherits office uh it includes um offered course offered course is started for you here so in this case let's pretend and not this is the use case I guess for this is you are a programmer and you're not the main programmer you're not designing the main the main program here you have to develop this Library a support Library Library so you need to to build the um the uh you need to implement these these uh these files here you might want to go back to the Linkin unit um from a couple weeks ago and study that if you're not quite familiar with how the header and object uh or implementation files work but essentially you'll need to define the classes in these these header files uh you'll need to define the the blueprint of them and then uh and then what you'll need to do is Implement them as as well so you'll have both of these to write um it's it's a bit of work um but you guys can do it at this point again if you need to go back to the the unit on linking uh to do this um it so uh basically you'll in the header files you'll be building things like this and including them where it I'm sorry not that not that uh where you're uh building you know just the uh the types of functions that you'll be building in the classes and then you'll be implementing with that colon colon syntax so those are a little different I might include a little bit more if you need it let me know if you struggle with this um but uh there's plenty of examples in those iBooks on just this um and if you need some solutions some work Solutions let me know as well um but I think you guys can do this and it's good practice to get thinking about things like this so what you'll need to do then is do that and you'll need to package up four files for me both offered both courses and and then your your make file which doesn't work out of the gate you'll need to zip those up and send them to me so I'll need to recreate your work basis for all five of those files for this unit one thing I did include here um because um uh you'll probably uh you may need a refresher on I did include this um compile notes uh oh let me let me copy that uh one sec let me get rid of this get so I I did it in I need to copy this into the assignment uh where is the here it is I've already packaged this up uh uh this this bit um you might need to run this syntax and I and I've got it uh in here as well what'll happen is if you run this this version of it it will make make an a.exe if you run this in the command line um it'll blow up right now because this this work's not done uh but what it'll do is it'll kick out an a.exe um or if you give it this o directive um the the uh output directive it will actually create a dried unit or whatever name you give it here aexe and then you can just run it so you might have to run that manually some of your environments not might not work exactly like we would like them too uh hold on let me make sure you guys can see what I'm talking yeah okay sorry lost my screen there for a sec I had to make sure that you guys could see what I was talking about um but yeah so refer back to the the actual assignment unit if you need to for that I did not get this update into this ZIP file here unfortunately but I'm going to go and copy it real quick uh uh into or maybe I did hold on I I may have uh not there but I think maybe into here did I put it up here oh I did okay yeah so you can grab that from right here as well sorry I just forgot what I wrote so that's it it's a big unit conceptually um I'm going to give two weeks for it probably dur right as we're leading up to the final it'll probably be the last graded work of the Year besides the besides the final this year in in 2024 anyway um I might introduce some stuff on structures and things like that but it'll probably be ungraded at least that's what I'm thinking thinking about right now where you can cover it if you want to so take your time with this but do start early um this is not something that if you've never done it before I expect you to be able to just grab grasp right away I I I fully expect that um office hours and things like that will be of great benefit for you to do this kind of work so please take advantage of that ask me questions just like always um I think that's all I have on this um I'm going to cut this video a little short I try to keep them under half an hour we're about 20 6 minutes it looks like we're creeping up right now on um but hopefully hopefully this is really kind of a a mind expanding unit for you on on how these things can get built um certainly when you build bigger projects or even work on open source things or things like that with other people this is something that you you you'll need to take advantage of is building on top of these things um and you can do this in other programming languages as well uh some of them just have different constructs for it so okay uh that was a lot please please come to me with questions though this is the main thing I want to I want to leave you with thanks bye