welcome to a unit that is really kind of one of those uh topics that re um kind of starts to separate beginning programmers from from you know where we where we want to be as programmers where we're designing with intent um and and building efficient and clean and reusable code um we've touched upon this topic uh in previous units certainly the function unit uh talked about abstraction a little bit and and breaking code down into smaller chunks well we're going to we're going to amp that up again this in this unit um this is an introduction um to an a programming technique called objectoriented programming and the big idea here is that we we start to think about what what um our program is actually doing and building a model of that um in our minds and then in our program we're basically modeling reality um into a computer program us things called objects or classes um at their Essence um well you know I'm going to I'm going to actually show just this one more time um where we were we just talked about functions and and return values and all of that and we're extending that um here into objects and classes um and there's a reason I skipped over um Frameworks in libraries here it's because objects and classes basically make up Frameworks in in libraries we'll study this a little bit probably when we start study graphical user uh interfaces you know guies up window window programs um but the way those work um and and the way a lot of programming works is we think about what we're building and we model our data and our our programming around the reality of the situation as opposed to trying to bring reality to our program and I know that doesn't make a lot of sense but hopefully it will by the end of the unit um so just just to recap what abstraction means it's basically meaning that we try to build something once um uh and do it very well and then trust it we we trust it and we reuse it um you know for example if we wanted to build say a a function or a program that would take a list of values and count them you know it might say um you know might might Implement a vector behind the scene um and as it Loops through and encounters things if it sees it for the first time it might uh create a new Vector item um and and set it to one because it's the first time it saw it and otherwise it might say oh I've seen this before and I'm going to increment so 1 to two two to three um so we might do that once and then we might build that into a function where instead of writing that every time we build a function that uh that um that that just does that for us where it just takes a list of items um and and returns a vector right um and we can just trust it to do that that's that'd be something we'd want to do where we wouldn't have to rewrite that every time we needed to count something something well we do the same thing with objectoriented programming um where we take lower level uh internal details and we we Implement them and and get the get something working um and then we we basically hide it and C++ uh gives us a lot of really cool tools better than actually python even does to to to do just that where we can hide the internal details of how things work uh to our to to somebody that's using it down the line and we we provide methods uh and other um methods being functions in this case methods and fun uh or functions um and other means to operate with with the our objects or our classes uh but we don't necessarily um have to know all the nitty nitty-gritty details um under the hand we do this by building essentially what's called a class um and a class is just a data type um built on previously known data types so what do I mean by that well a data type as you know is you know an integer or a character um strings you know doubles floats all of those things we talked about back in like the math unit units one and two those are all data types well we can start to combine those and say you know if I wanted to make a a new type of variable called a name it might have a first name and a last name um well a first name uh is a bunch of is just a string right and a string by uh Association is also just a bunch of characters so these build upon each other and then we might put a first name and a last name together where they're just two different variables but they're wrapped together so it treats it as one one uh one object in this case or a variable turns out every every variable we used is an object there's just different ways to implement them under under the hood and some of them are built into C++ what we're doing here is building new types of variables um that we can use to our own end and we can add things like methods and uh and other nice bells and whistles uh to help us Implement um our idea of what's going in the world um looks like I messed up my coloring here but let me just fix that real quick while we're while we're talking um an abstract data type is basically that right where it's it's taking a data type and uh saying we're going to build something new um and they're uh they're they're um they're uh it's new and useful for our purposes and hopefully reusable um so what we'll be talking about a lot in these first couple lectures are what C++ does to give us this technology or or the technology we can use to implement our ideas in this in this way uh sorry I always forget to hit the the stinking full screen there we go that should be a little bit better um uh uh but the idea though is that when you're programming you start to think about what things exist in the program you're trying to build and what each thing contains and does what it contains and does those turn into our variables and our methods uh in a class so keep that in mind when you're thinking about something you're trying to build a program about think about the things in that program and what each thing does and what it contains so with that in mind let's talk about this idea of a class um a class is a blueprint um that that basically lays out the the um the flow or or the um the uh the uh the capabilities of a new class I'm going to try to make PowerPoint just a little bit smaller I can make this just a little bit read little easier to read by making oh that's not what I wanted to do at all well that didn't work that's okay um hopefully you can read this um here but the idea is we're making a class here uh that um that uh contains um looks like a number um and it's uh and then uh it's initializing it to zero um the uh the main thing though that we want to start talking about is this idea of a public member and a private member um and we use these words here in this class so this class is a blueprint here um and the things in public you can get out directly so um this is in in this case is a function definition that we'll Implement later um and we'll see that how to do that down here um but we're saying this is what so uh it looks like it's uh function factorial one something fct one whatever that is um and then but the private number a here um is uh is a private member we cannot get at that we can't get at number a directly after outside of the outside of the class so we'd make a class called uh my class and we'd give it a variable name we might call it class you know we might created something like uh my class one uh or my class class one you know something to that end and then we could we could get at uh the the function one but not number a um so the main thing to keep in mind here though excuse me the main thing to keep in mind here are things that are public you can access when in when you're creating variables or objects of this class and I'm going to make my picture just a little smaller I just realized I kind of can't you can't quite see my uh full slide there you know I'll go and make PowerPoint just a little bit bigger while I'm doing that like so so you know I might be able to do play with this a little bit too it's a little bit better anyway uh sorry kind of playing with uh OBS Studio here as we go um but the the idea is that the things that are in the public section of your class definition you you access those are the things that your user will your or you it it doesn't have to be your user but people using this class will use the things in the public method the things in the private section are the things that get the work done that but you don't necessarily need people uh to see and it's not necessarily because it's like a security thing or anything like that it's just to reduce complexity say you have a very complex class that say I don't know runs a guey program you know runs a a game even there's a lot of things under the hood um that you you don't need people to see like like you know for example uh you might have an X and A Y position of a character um and uh and you might make uh but people don't necessarily need to get it that directly um or even manipulate those but you might make a jump method for your guy and that would in turn uh work with X and Y under the hood we'll see that a lot um just a little on syntax um and I'll probably break after this slide um the uh when you create a variable of a of a of a certain type that you've created it creates an object of that type and I was trying to kind of talk about that earlier but you're basically make objects with classes you can think of this like when we say int age you could think of int as the class and age as the object instead of a variable it really is a variable that's all these things are um but you can think of objects as variables and your type your your class is just the type of the object and the only difference between what now what we're doing now and what we've done before is when we create classes we're just making custom types but we still have to declare things as those types so we we do the same exact thing and when we use that class type like we see here um I don't have a great example on this slide we'll see it soon though um uh the the the uh when when we do that it actually uh C++ will actually create memory for that just like it does when we talk about creating a primitive type like an integer or a character it creates you know that little footprint of memory when we call that well it does the same thing for an object uh when we use the class it says okay I have a class of four in and three strings so I need that much memory and it turns out it also creates things like spaces for its methods it's instructions but that's a little beside the point um so when we create a class we create a function declaration um and this is opposed to a function definition which is what we're a little bit more familiar with um you'll see here when we create a class over here we create um we use this void uh I'm going to say Function One um here and that is our that's our function definition it's a void type we studied those before and the name so we provide a class name a type and and the parameters if there are any in this case there aren't any um uh and then later though we provide the function definition the function definition is actually where we do the work so that's what we have down here and it it doesn't make a lot of sense uh to do that uh at the beginning why am I doing this twice well the idea is that you keep your class blueprint fairly uh small because it turns out you can move this around into different files and things like that down the road excuse me uh you can move this around if you want to the class definition um and Implement your uh your your functions somewhere else very often you'll see the the class definitions put in a header file um and then you'll um and those don't change those stay in place but then you'll recompile your um your your code that actually has your uh class definitions as you implement them so you're only implementing one thing over and over again uh there as opposed to keeping it all in one file um and it's also useful to do that um if you're working in a team because you you can provide the class definition to all your team members why one person is working on the class actual implementation actually building the thing um but you you know what the thing's going to look like and hopefully what it does if you have if you have good documentation um so again a function declaration provides essentially the skeleton which is the name return type and any parameters but not the the function statements the definition actually uh implements that and we see this this double colon so um if you do it later if you if you provide your function definition later what you do is you basically say this belongs to my class here right so this is this is the the function one of my class that's what this double colon stands for um as opposed to to something that would just stand alone so if I just put function one outside of this it would just be part of the program that you're in just like what we've been doing and what we did in the functions unit so what what you you need to be careful to make sure that you use this my class colon colon syntax here to say this belongs to to my to my class it turns out in modern C++ you can actually do what's called an inline function and you can put your you can Define your function in your um in in your uh class definition as well um either is fine with me I don't really care but just know uh the differences so you don't have to obviously put my class colon colon if it's in your class but you can um sometimes you'll want to do it one way or the other just for your own organization I'd advise sticking to one or the other just for your own sanity uh but it's not necessarily a strict thing so um I'm creeping up on time so I'm going to pause here stop and we'll call this one the intro and then we'll get into more of this idea of encapsulation here