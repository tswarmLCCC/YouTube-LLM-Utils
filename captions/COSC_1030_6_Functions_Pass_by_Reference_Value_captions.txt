one one of the biggest things I think that a lot of students or not even students just programmers that are starting out uh using functions and starting to think in this abstraction you know kind of mindset where we we take an idea and we boil it down and we have an input and then we have a return value is is this idea of what what happens when I want to have more than one return value or what happens when I want to you know change a variable in place right so you know let's say maybe we had I don't know a string um you know of lowercase Trevor lowercase T RR and I wanted to write a function that said capitalize the first letter one way we could do that is to basically write a function that takes the the lowercase string and it says go find the first letter and capitalize it make a variable of that and then return that and you could store that either as um a new variable or uh uh or the same variable back in main program right you could certainly do that um but there's there's a way in C++ in most programming languages where instead of um of taking a variable and um and modifying it and then reassigning it you can do what's called pass by reference um as opposed to what we've been talking about which is pass by value but to to to describe that we really need to talk about what happens when we we build a function so when we build a function function um and we pass an argument to it what happens um let me go back just to one of our other examples what what have what would happen with our uh hours of minutes to minutes is um when we call this thing like down here um it would take say these were in variables this one and this zero I'm sorry this one and this zero here were in um were were in variables it would actually create a copy of those to pass into this that exist while this function's being called so um our hours to minutes gets called and it see it says okay I've got this original hours and original minutes variables it what would happen in the computer is it would take a copy of those two variables and make another copy that are used only when that when when that program is being called um that's called pass by value um and it's called pass by value because it basically just takes the value values of the functions it makes new new copies but the original copies are are are not changed at all so um if I took original hours here and I added 60 to it and I assigned it back to original hours the original uh variable called that it was called from down here it wouldn't get changed um that would not change in outside of the program and we've got some really neat programs in our Prim exercises to demonstrate this for you where you can see that there the original variable isn't touched when you pass by value um that's the default mode in in C++ passing by value so when you just pass a variable to a function um all of that data gets copied um and sometimes that can be quite huge right so if you say you've got a million element Vector that you pass into a function and you want to iterate on it and print everyone out or some no let's let's not say you don't want to print them up you just want say there's a million numbers in there a Million numbers that you write in from a bank account or something and you just want the the the total of all of them well what will happen is you'll pass in that Vector it will make a whole another copy of that vector or array if you're using an array and all million copies will then get a second copy in your memory and then you'll it will run through those sum them up and it'll return the sum right which is might be what you what you want to do um well what you can do instead is you can do what's called passing by reference and you do that by using this Amper sand here before your variable and what happens when you do that is it instead uses the the original variable and that has some pros and cons to it that you need to be aware of the pro is that it's only one copy it's the same so basically instead of making a big old copy of a million things it just says Nope I know where that is I'm going to use it the con or Pro depending on what you're talk you know how you're using it is that you can modify that so if you for example changed a number in there the original would be modified this has done a lot lot in strings um in string functions where um you know when when you when you call a a function on a string very often it's just modifying it in place um and a lot of programmers tend to to gravitate towards passby reference um and and uh and just U having access to the original variable um but uh the idea though is to make sure that you know what you're doing when you use it um make sure that you know that you can modify original um variable and and and uh and that may be what you want may not be what you want um if it's not what you want you might consider using the word const co co NST and what that says is this function is not allowed to actually alter that that value um uh so if if you intend to alter the value don't use const it's pretty simple but if if if if if you're only using it as a as something like you know say you know return you know um the sum of all of those numbers then you could say the the V Vector is a constant I'm not going to change it I just want access to it without making a whole copy um you can certainly do that as well um so there's a lot of ins and outs of that um but the idea though and just to reiterate is when we pass by value we make a copy of all of the variables we're passing into it when we pass by reference we're actually just passing the locations or references to those variables and we can modify them directly much lower overhead but the um but and a little more power to alter those variables directly just something to be aware of there um that uh all has to do with this idea of scope um but I I mentioned it earlier but it's worth repeating uh variables inside functions only live while that function is being called the same is true of if statements for Loops anything with a block basically our curly brackets are a good way to remember that anything within there you know if you declare a variable in there once you leave that area it will not be available anymore now if you call a variable you can you can usually uh in if statements and forward loops and other kinds of control statements you can actually access variables that are inside the block within the block that's okay and those are basically passed by reference you can modify them but they and and then you would still have access to them after the fact but if they're declared within that block what happens is it gets cre created on What's called the stack um in your memory and it only only lives within that block and it's only there to do the job that you're doing in that block or function and then it goes away it goes away so um be be mindful of that uh as you design your program and where you create things as As you move variables around and you're trying to debug sometimes you'll move things in or out of blocks or in or out of functions and you might not have access to the variables you need or conversely maybe you need a bunch uh and this is a great reason to write functions maybe you need access to a whole bunch of variables but they're whole purpose is to just do one or two uh things one or two calculations and when you return that value you you're done with all of those um so that those could be very very useful um sometimes what what'll happen um oh and the other the other thing and I mentioned this earlier is when you call Define functions um you or when you try to call functions they need to be defined first um before you call them and the way you uh so basically that's just in order going down your program so you need to Define your function before you call it now a lot of people will get around that by um building what are called function prototypes which basically say this is a function that's going to exist at some point but it's just the definition um and then they implement it later um and and you can do that uh uh you'll sometimes you'll see these things called header files uh included in programs and what those are um are and we'll talk about this in just a bit a little bit more but the idea though is that um you can put your functions in a header file so you don't have to copy them into every one of your programs so you're basically copying a file of your functions into a program and then you for example call Main when we talked about unit testing just a little bit ago that's a great example of when you might do that you might Define all of your functions in one file and then you include it in both your main program that you want to run for your user that you're actually doing the real work with but you also might want to include that where you're doing your testing so you're only changing the files in one place or the functions in one place and then you include them in in your executables where you have your different main programs and you call those separately um another reminder uh just since I kind of stumbled upon it in my brain right now um we we're using repet uh for a lot of this work and you can only have one main program in a function or in a in a um in a project in repet as far as repet knows um so the way we get around that instead of using that run button we use the compiler and we just compile the the the the only the functions we need uh at the time and you would just simply pass the difference uh CPP programs or header files into your um into your compiler uh whenever you're running uh we'll do some demos on that very soon though excuse me got the hiccups there kind of got talking fast but the main idea though the main idea just to have a bit of a takeaway going back is that um when we pass by reference we are passing the basically the original variable um you can think of this in memory so if we got memory here right for our original variable and memory here for our second variable or for our Heap when we pass by value it takes this and it copies it over here and says do your work here and then return back to this one right if you're passing by reference it's say this is what you get only look here um you know it's it's it's actually a pointer is what they called uh it's actually the memory address of that that get that gets passed to the thing instead of making a whole new copy of it um and we'll we'll cover that more in 2030 than in 10:30 we do cover memory management just a little bit here but that's the that's what actually what's going be on behind the scenes if you've programmed before or heard of pointers that that's what they are they're basically just pointing to where the memory is living on your computer um and when you pass by reference it actually just says okay I'm going to work on that original location as opposed to making a copy and working on that so pass by value makes a copy and you work on that which keeps your original value safe but it makes a copy and it's a bit of inefficient pass by reference conversely works on the original copy does not make a copy so it's a little bit faster um and gives you some upside that you can modify in place and things like that and you can modify uh each one of your parameters in place as opposed to having you rely on a return value if you wanted to so some pros and cons there um hopefully that Sol solidified uh you know a little bit of uh what you saw in your reading especially if it was confusing this is a big idea of of encapsulation and not one that I would not I would I would not be surprised if this is confusing you please come uh and let me go through some programs and things like that if this is something that you're struggling with um it's a great use of office hours we can demo the heck out of this um I've got multiple repats already set up and I'll certainly have more by the Fall when you guys take this class um uh on demoing these things but uh big concept here and I wanted to give a very succinct video on this one so uh anyway uh let me know if you have any problems with that and we'll got a few just odds and ends of our functions to wrap up in one last video uh but nothing nothing quite as dense as this so if You' gotten this far good job good job and we'll get to that last one here in a bit