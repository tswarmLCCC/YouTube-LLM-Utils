in extending our idea of studying Loops um in their different in their different um in their different definitions uh you know while loop and for Loop um we come across this idea of of repetition um but that's not the only kind of repetition that we have available to us uh as we build our toolkit and start to um model um data and problems um we also have this idea of collections um uh most commonly known as arrays in traditional programming at least um uh in in C++ we'll also introduce a specialized class called a vector which has some nice functions for us um in Python if you if you've taken one of our previous classes especially 1010 um that you might uh um you might um kind of the analogous structures are lists and um dictionaries especially dictionaries vectors and dictionaries are very very similar and they they share some common um they even share some common functionality but the main idea of all of these things is that we're basically collecting information um or data um you can think of when I say data is a bunch of different variables a bunch of different variables we're collecting them Under One Roof for lack of a better term so what what a collection or an array or a vector is here is basically it's it's a data structure rure it's a data type that holds um that houses many other cop uh many other smaller data data types uh in one shape or another most often um these uh data types are of the same type um they and certainly both of these ones in C++ that will be the case um as opposed to dictionaries uh or lists in Python where you can have multiple different kinds of data types in in in those structures in C++ they they need to be the same type of structure um and what happens here is um you know we might make say we needed to store 10 a 10 10 uh 10 variables uh for different ages say we have 10 10 10 students and we need to store their ages for some reason well one way that might happen is we could allocate memory using our very bad memory diagram that we've used before you know much like we used first name and and spelled out Trev here that might still be living out there but if we needed to keep ages say we got a five byte uh uh age type and that there isn't one they're usually even but let's just pretend for the sake of argument that there is we just make um we'd find memory for for five of these now they're usually lined up in order which makes them faster so it'll usually find a block of free memory where it can find space for all all in this case 10 in a row variables and then what it does is much like first name points to the first part of the string um the the variable or the um the collection name variable name Will point to the first uh first location of the first item um uh it turns out strings are an array of characters as we talked about when we studied those so in this case in my first name it it points to T here and then we have r e and V but it's basically Al allocated space for four characters here um and there might be some leftover space here that was allocated that we're not using yet or that might be the end of it but the point being is these are things in sequence of the same type that we can access quite quickly um each uh item in a collection an array is is known as an element and each element's location is called the index so R here in my name would be the second element and its index would be one zero and one remember these things start from zero not one so the uh e likewise would be uh at position three its index would be two um but it would be element three and its value would be e um so that's kind of how these things get laid out in memory uh but the the point is is us these things um uh the native arrays the ones that are built into to um C++ they will you need to define those up front with how much memory they'll need how much room how many spaces you'll need how so in in our case we have 10 so you need to allocate 10 spaces of probably integer um and it would go out and find that much memory and just hold that uh and so you'd say you know int age equal uh um in age and then we use the um the the square brackets the the square brackets up by your ener key there to hold the index the the number of items that's also how we get at the indexes uh let's see here I think I talk about this on this um actually NOP I I go right into vectors um so a vector is a little bit different than an array and it's a newer thing in C++ um a vector is an is a list and it gets ordered um by by default the these things uh will be ordered and uh um they're not baked in to to C++ directly you need to import a uh a library there you don't need to download the library it's it's included in modern C++ uh installations but you do need to include Vector at the top of your file to use it um uh so you you uh you can uh uh you include vector and then you can um and then you can declare these things with the vector type that's Vector type and then what you do is you give it what's called a template so this would be like int or or character or string or any anything you want even objects can be put in there and then you give it an an identifier name right so um you can also give it an initial number of these things uh where you uh you uh you give it a parentheses at the end um and that will set up memory for the initial location but it turns out um the vectors you can add add more elements during runtime or you can't do that in Array so that's a big difference and we'll talk about that at the end but with arrays everything needs to be the same but you only get the amount of space that you allocate there's ways to do it with pointers and and dynamic memory allocation in C++ but uh vectors you can just um you can just append uh just like in in in Python uh you you can append things continually or you can um you can add some other operations that um all of these are covered in your book I'm not going to go through all of them but you can um you you can um basically create a a memory on the fly so for example if you wrote a simple program said how many names do you want to to use and you could have somebody enter that you could use that that input to then dynamically um uh to dynamically allocate the memory what do I mean by dynamically allocate that's a great question that might come up um so there's there's a difference between program design time allocation and runtime time allocation in with arrays almost all the time you have to know up front how many times how how much memory you need to grab you need to basically put a solid number in your in your uh array declaration syntax up front um in in the brackets to say I need 10 or 20 or 50 or three of these whatever it is but you couldn't put a variable in there you couldn't read in a variable and put that in there you can do that though with vectors or you can just Loop through and keep appending things uh as we'll see many many times in our examples as well um the other uh nice thing about uh both arrays and vectors is that you can use variables to grab at different parts so you can use the at syntax in vectors or you can just use the bracket syntax in um in arrays and you can use um a variable in there so if you're in a loop for example a very common iterator is I so it's go you know zero one and two well you can use those Loops to to grab the current um the current uh the current element uh of an array or vector so with vectors we use the at operator or method which is part of its class which basically says give me the element um from usern nums at the position I and I can be stored as an integer either you know just directly you could input it you could Pro call it directly or you could be looping through it um one other really cool thing about vectors is it has an equality operator which um performs exactly like you would hope it would do basically it says are are the two vectors of the same length and if they are it's going to go through item by item and make sure that the item contained in those vectors is I is Extreme exactly identical as well um so it does both of those things for us um one thing uh that uh all of these collections do and I try to hit this anytime I introduce collections is basically we we organize related data and keep it under one one name uh you know like uh names or houses or whatever we're talking about here and then we we are able to access those sequentially or independently if we need to but we can Loop over things things like that uh we can quickly get things in vectors with their keys um and uh recall that a key a key value pair is a name that's uh that's given and that can either be a string or most often it's just a number and you can you can use uh you you can use those as well to to get these things um but that's a very handy syntax because you can use these things you can set the keys yourself as well in vectors so um one common example that's come that comes up a lot in my finals is the need to count things as you encounter them um you know for example if we were counting like the number of first names in a file um and let's say it went like you know you know Trev and then uh John and then Trev again well the first time we encounter Trev we can say okay we need to insert a new holder um and set it to one for the first time we've seen Trev right so the idea would we we' append a new item into our Vector uh called Trev uh and that would be the key and then we'd set its value to one because that's the count right and then we'd do the same thing for John when we see that but then when we see Trev again instead of inserting a third one we go back and look up the key and say does that exist so this would be part of our logic and we increment that one to two um so you can count those things up and we'll do a demo of that in the code here when I write those I haven't written those yet or i' show it right now but it's a very handy way you can do uh use vectors uh you know dynamically um to to do some interesting interesting operations the main point of of this slide and really collections in general though is that we're keeping things that are of the same type or of the same you know design or serve the same purpose under one one variable instead of keeping multiples of these can you imagine you know if you had a hundred names uh you know making name one and name two and name three dot dot dot name 100 well then you need to print those you literally need 100 print statements where um what we do uh in in um in C++ or any other programming language that's much more elegant though is we store those in some sort of collection in this case uh vectors is what we're talking about um and we will Loop through those and only write the print statement the one time and we use the same code over and over again as we iterate over our collection to swap out the data in there and that's kind of what I was going with for that other poorly drawn slide but let's take a look at the syntax here uh which is important um and and we'll talk about exactly that idea of loops and vectors which is why they're included in this unit loops and vectors can certainly be used independently they have multiple uses in um you know uh by themselves but they they're really they really work nicely together um there there's a lot of problems that you can design around just just using loops and vectors so the syntax for um a vector uh in a for Loop looks like this um we have a size member of uh of of the vector class that returns how long how how long it is so if we have a 10 element uh Vector that size would return 10 right um uh and uh actually I think it does nine because we'd want it to be zero right but the idea is that we start at zero and um why we iterate this will say while eyes nope actually it is 10 because we want it to include nine so this would execute on the on Z 1 2 3 4 5 6 7 8 nine but not 10 right so this is this less than keeps us from grabbing something that's outside the size of that vector and then we iterate it just like we always have I'd recommend i++ here just like we talked about in a previous video to do that so let's take an example of that here we're basically having a user put in a bunch of numbers and um and uh when we have those uh we're going to um uh I'm sorry we're first going to have um users um let's see oh no here so this one we're basically saying why we have eight eight uh we're going to have people put in eight numbers although you could read this too where did my mouse go you could read this eight right um and then we're dynamically allocating that number so you could not do this with arrays right uh but because uh we're using vectors we're basically saying give us eight of those so this this um this parentheses syntax here you don't need this you could you you could start this with none in a pend each time or you can just say I know I need eight you could do either uh which is not true of of arrays again um and then we're going to basically have people enter these things and um in this case uh it's going to go through um and uh let's see yep it's going to B basically just give a user prompt and then for each one it's going to kick out the word value and wait for people to write in a number or anything well it have to be a number because um the the type inside the vector is an integer here and you can see this because we tell it in its template that it's an integer and that's required you have to tell it what kind uh of uh variable is in there but once you've done that you can add as many as you want and then we're using this um we're basically setting uh and um if we hadn't done at or this um saying there's eight of these things so we've got eight slots here we would have to append these things or push back one of the two which we see in the next example um but because we did we already know that there's eight in there we can just say you know uh the uh we're going to basically say um uh put put the uh user in user number into the position at that so it goes 0 1 2 3 4 5 6 78 uh8 uh or 0 1 2 3 4 5 6 7 um but the four Loop would then stop because we have a less than control here but you can see how um we use the size to control the size of our for Loop or the length how long our for Loop runs here and then we use the at I which is being incremented each time to use it in our indexing right that that's how those things play very nicely together um another way we could do that instead is instead of dynamically creating them so you'll notice the difference between the vector calls here this one does not have the number of values dynamically allocated or allocated uh right there so it does it's basically an empty an empty Vector at that point but what we can do instead is we can use this push back syntax after the value comes in and it will just add one more and one more and one more at the end that's what push back does and there's other ones that you can use you can insert them at certain positions and things like that um but we still do use the very s very similar syntax but instead of using user value size here which you you still have available you could certainly do it and we we use it later again um uh but user value value size would be zero here so we can't use that but we do know how many number of elements we want and we push back each time you could access the size each time but you would just see that it's an increasing number so it would not be appropriate to use in the for Loop here you would absolutely need to use it uh this would basically start out is zero I'm sorry not this uh the uh if you used the user value size in this kind of loop um it would start out zero and then the next time it would be one and two and three as you push push back values that size will increase is my point um and it's important to distinguish between the two this one knows up front because we told it how many values go into it just to reiterate that point this one did not this one did not do that so we uh we use uh dynamically memor dynamic memory allocation to add values to this thing all the time um and and and thus we have to use a different control for our Loop but you see here at the end uh these things look very very similar after and we can access them after we do that we can use the size because this has been the the size of the vector has been pushed up to eight now um and we can go start a new Loop and in this case do su a summation of of the thing and we uh we we keep adding to the so we started at zero and this just grabs the value and then adds the the current value uh to what's ever in that element and then sums them up that's to to Really uh kind of common uses of vectors but there's a lot of neat things you can do with these things in general um so I've kind of alluded to a lot of this but there's a lot going on in this slide um the uh arrays use the uh bracket syntax and they have you absolutely have to do this well not absolutely I I need to I need to um I need to kind of I need there there is a way that you can um add more memory uh or get bigger arrays but they're not nearly as useful it's not near as easy as it is with vectors basically you make a whole new array and you use a function called Malik memory allocation and it copies the whole thing over which is very uh inefficient uh but arrays are very efficient if you know exactly what you need ahead of time um arrays uh as opposed to vectors are built into C++ so you can make an array of any type um by simply giving it the type up front and then just uh giving it a name and then you say how many you want so this is going to be 10 integers right the same thing can be done in vectors as we saw with the optional parentheses the optional parentheses um and we do need to give it a type as well but uh you you uh you just set those up a little different remember that this one does not is not built into C++ so you need to include the uh include hashtag Vector directive at the uh top of of your code to use it um the they're accessed slightly differently um you use the uh bracket syntax again uh with either I or a direct number so I could put 0 1 6 in here to get those respective elements I have to use the at syntax in vectors to do that um yep let's see vectors and arrays uh can both have multiple Dimensions um you can set up a two-dimensional array by just using another Square syntax here so this would be array an array of of the set number of rows and columns so for example if this was two and this was three you'd have six total elements but you would access uh you have access uh to uh two rows and three columns of the data here um which is a very nice way to um do this you can do the same thing with vectors where you uh basically put vectors within vectors so the syntax is quite a bit different there um the idea though of uh of arrays is that they're just simply values that are stacked the the the co the the pipes here are just just to give some separation they're not actually um in in the code um I just put those in to kind of help you understand which element was which but a Four Element array would be like 90 and then right next to that would be the value 85 78 92 just very simple very simple um and you could access those with 0 1 two and three right as your as your indexes with the uh with the square bracket syntax um vectors on the other hand they have a key value pair um so let's pretend we were storing ages of people or scores on a test um you can actually access these two ways um I could get Alice's value of 90 by saying give me the vector called Vector element called Alice so these need to be unique I think I don't think you can have more than one I have to check on that um some programming languages you actually can but I don't think in C++ you can um but you can access it by Alice or Bob you know to get those or you could go 0 1 two 3 and four just like we did up here um you could do that as well um other than that uh vectors can grow and Shrink um you can use the resize that's kind of what we talked about earlier where you you say hey give me maybe we make an empty vector and we say hey uh user tell me how many scores you want we could resize it then to that number uh you can append you can pop to the back like we talked about B layer uh where we just put things at the back um things like that I'm trying to think what else I want to think talk about these things these things are much uh easier to play with in code uh but um multi-dimensional arrays oh this is a good point um we studied just at the end there um of the loop unit we studied um uh nested Loops nested loops and multi-dimensional Rays go very very nicely together as well so you might recall that we did the you know the alphabet and then the alphabet again where it goes a a a a or it goes a a a b a you know all the way down to a z and then it goes to B well you could think of that outer loop sorry I'm doing this backwards I'm backwards on my camera the outer loop as your as your uh First Dimension of your array which would be the rows and the second one is the columns you could fill those in too so again you should play with that you should get used to these things especially with um nested Loops um that those sound like great examples that uh we should uh totally hit in the code and I'll try to do that but they're in the book so uh certainly work through those examples if if you if you uh if you see them um uh which is why I use side books they they have those nice uh those nice exercises and I think yep that's it that's everything with uh with uh Collections and arrays but um they're these are the workhorses of of LGE you know programs that do a lot you know we we've quickly gone through three big things where we went through conditional statements which use booleans uh Loops which use booleans and then these lists that they can kind of iterate over store read to and from and all these things a lot of these things a lot of the rest of the unit like files and functions they make use of these things to make our code either easier to read or we store data differently like for example files um Loop through you know either a character or a row at a time all of these things start to build upon each other as we go back um and talk about you know the tools here you know that's why these things are you know kind of together here um and uh we'll see that these things kind of all are the these guys right here basically everything we've done here uh really through here maybe without IO um these start to make up things like functions and and objects and classes that we'll see uh but um you've got a lot um from where you are right now you've got a lot of the toolkit that's going to serve you well for the rest of the the rest of the course oh my goodness I did not realize I'd gone this far over on my time um well I'm going to stop this video I might break it up if I can find a nice point to do that uh but I kind of kept talking there so we'll see how that goes all right sorry to go over time on this one bye