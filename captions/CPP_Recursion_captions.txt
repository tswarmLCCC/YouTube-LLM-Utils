hello and welcome to the unit um on recursion or at least the the first unit on recursion we'll study it um as we get into trees if we study them as well depends on actually a few things where we're at in the course um in terms of the weeks left we might might not be able to study trees or if our publisher does uh there's some material I'm trying to get uh that uh goes in further into what we studied when we talked about um when we talked about uh searching uh right before spring break that that unit um searching uh with binary trees and things like that it expands on that and goes into trees a little bit further um uh and uh it uses a technique called recursion to Traverse these things there's very cool interaction between the two and I hope we can cover the whole thing but I definitely want to recover or cover for the first time I'm finding uh for some of you this idea of recursion um and we'll start with C++ I might do this in python as well I'm not quite sure um for those of you that didn't get a chance to cover it in Python um so this week uh is a precursor to a trees unit that we may or may not get to as you can see here um there will be a uh guided learning um that uh in zybooks uh that covers let me go to the assignments real quick uh that looks like this it's not much in terms of reading it actually is pretty fast but there's some heavy heavy Concepts in here recursion is not a light subject um so to start to introduce recursion the idea of recursion is a it's a function but it's a function that can call itself to solve certain kinds of problems the idea that is that you know we might for example have a huge problem that we can break down into identical steps to make it smaller and smaller and smaller till we can get to what's called a base case um so for example um you know if uh I'm trying to walk out of this room and I'm already standing up um it might be you know take a step and turn to the left and it might be take two steps and turn to the left and it might be take three steps and turn to the left that kind of idea where there's very similar things but things get just bigger and bigger as we go um that that's the idea of recursion um anyway we've got some reading on in here uh as well um and there's let's see where's that recursion unit there quite a bit in here and um there's um there's some some I think I've turned them all off but there are some um uh some uh challenge units in here um that might be worth your time as well if you're struggling with the unit and first time you've done it I don't see any yeah here's here's one for example these would be might be decent things to to start uh playing with um there's a lot of code here but really getting to know what's going on here uh can be huge if you do that I don't recommend doing in zbooks I completely recommend moving these into vs code um or repet if we're using it um and setting stop points and traces and doing a lot of printing in here so you can really understand what's going on please don't do these WR and zbooks if you've never done them before it'll make your head spin um and it's just not worth the head uh but the reading itself is pretty good it does a pretty good explanation of introducing this idea um I also wrote a little bit of a topic page um that has some very simple examples uh that really gets into the big three and I'll get into this into into in the slide deck here in a sec but the main idea is identifying what's called a base case it's the very simplest version of a of the algorithm that we're going to solve and then you can you want to be able to break your progam your problem down to get to that base case um so there there's a little bit here and a bunch of reading material I found um with the help of AI and some of it um one of these uh uh is really really good it's this one actually oops not not Cinemax and and water guy here we don't care about that but the idea here is that we have a very simple function that that's doing uh factorials right what's 1 * 2 * 3 blah blah blah for n right so it takes in you know a number let's say five and it goes five 5 * 4 * 3 * 2 * 1 right which ends up being of course you know uh 15 I want to say or I'm sorry not no that I'm sorry that's doing the addition anyway the idea though is we can break this down um to use uh this this is why I really like this one so I'm going to actually put this uh uh uh in into the slide deck as well here uh let's see yeah here we go I'm just going to put this right at the end of the slide deck here uh yeah let's make a new slide we'll just stick that right there just in case you need to actually look this up so not not a crazy you know kind of a silly name but I really like how this guy did this where um he describes what's going on so the idea is we take factorial n right and we write this kind of function uh the whole function looks like this where if n is greater than one we call this same function again right that's the idea um if not return one so the idea is that you get this thing down to one and these are integers so we're not dealing with like any decimal points so if it's like if it's three uh if it's factorial three it'd go you know it go through here and say you know this is true so return 3 * factorial n minus one which is two it still needs to figure this part out out so it calls this whole function again and then calls it with two now this still exists it's going to come back to this with three and two but then it's also going to build a new version of this where it is two and then one and then when it gets to one one's the base case here it's just going to return one so then you'll get then you'll get 2 * 1 and then that'll be able to return the three and two or two and three sorry two and one version and then that can return the three and2 version to three right so we can we could draw that out um uh in uh you know maybe we'll do that in class a little bit and then the idea is that it it solves it all so what happens here is it basically calls copies of itself as it decreases and changes this slightly until it can solve one of them and that's why it needs what's called a base case um so that's the general idea I really like this guys uh for from the reading that's why I bring it up here um and uh and uh um and this is a decent one uh the uh so that's kind of it uh and uh in terms of what we'll be doing this week um I wrote a unit page on that uh that's right here and then there's going to be a program that came from a previous version of a shell we've got many many examples in our assignment though as well I haven't L even linked the assignment go and do that right now actually uh let's see there we go just add that right now while I'm thinking about it put that here and put that there uh and then we need to do a quick little uh header sorry I don't want you to uh the reason I'm doing this right now is I don't want you to think that you have to do this other thing that that's going to hang out in there this is additional material like that so this is what it'll look like like so the assignment would be the guided reading and the recursion and there will be a discussion that I haven't wrote yet um so the weekly overview though is is very simply uh some guided or some learning objectives um and then the lecture will be posted here uh don't know what's going on I have to check that out um the it'll be posted here and then here's a very simple python example that I like how he talked through it as well um so I might put that other link here as well okay let's get into the lecture before we get into some assignments let me bring up PowerPoint here and there we go there and we'll go up here and talk a little bit about recursion so recursive algorithms um are is an algorithm that breaks the problem into smaller sub problems like we talked about we're trying to make the same thing to but the idea is we're using the same exact code to go smaller and smaller and smaller until we get to the smallest part unit and then we we do a little Branch there's always an if and an else in there to get to What's called the base case um and it's a special case that then gives that key key brick that you can step on and say okay now I can solve the very simplest case and build back up to solve the rest of the recursive cases that's the idea of of what we're going after here um let's see yeah I just want to make sure didn't so the idea here here's an example of binary search we just talked about this uh so the idea here and I'll I'll leave this up long enough or you can read this if you want to um but the idea is we have a binary search um algorithm that calls itself so um our base case is basically saying um that uh here's our base case it's it's basically what this is doing is giving um a low and a high range um it might be big to begin with and it keeps making it smaller and smaller and smaller um until our key uh is found right so uh what what it does there is it says grab the midpoint of the high and the low uh the mid high in the low index here and grab the uh value at that so that's what's going on here it's basically grabbing the array value at the midpoint and comparing it to the key and when it returns when it find if that if that's true it returns that thing if it doesn't find that it basically just keeps making the uh the uh mid and low uh or it basically goes down two paths it'll go down this one uh the left one and the right one on a tree uh where it's uh using the bounds either from the beginning to the middle or the middle to the end um to uh to to CH chunk these into smaller and smaller chunks but the idea is we keep getting smaller and smaller and smaller until there's nothing less left there and we find that one and then we go back out that's the idea um so here's a quick implementation of that we'll study that more next week I don't want to get too much into the details of that and how that works it's really a fun one it's a cool and very powerful algorithm in its own right but um I don't want to just go through an entire binary search algorithm discussion right now but this is how it works if you're interested uh the idea though is that we have a base case or we keep doing the same thing where we go smaller and smaller so we're changing it each time see this mid plus one and so the we're going from the beginning to the the middle point or the middle point to the high point um and so we're making our space smaller and smaller um until we get to the base case and then it just goes back out pretty cool um oh and there one thing about this our zybook I think it's on the second one and that's actually where this code came from as well um it's got a very cool page on printing with like indention and tabs to help explore how this uh breaks itself down comes back up highly encourage you to run that one as well so uh what what why do we even use this thing besides binary searches and things like that well there's a lot of cool math problems that can be solved this way um factorials uh fractals which I drew I found a picture of fractals are a graphic thing where basically this is the same thing that just reoccurs over and over again um and makes some cool art and you can Google these things they're kind of fun and you can see them spiraling off into into infinite infinite space it kind of makes your your head spin but it's a lot of fun you can write these kind of things with uh with recursion though that's actually how they're written uh the Fibonacci sequence we we'll we'll see an example of that in a in a second here um building uh possibil the combinations of a set so like if you got like uh like three three three words you can like say A B and C you could do you know find every combination where it's like a c a CB B A BCA all of those and you can make this you know much bigger there's ways to do that um and in math that of course leads to all permutations and combinations which have some just immens of applications uh in uh statistics and data science um and some other ideas like uh Network traversal finding the the least costway through a uh a a network and things like that um uh and and and you might want to study those if you're more interested in those as well again I'm trying to just be an introductory unit this this could be almost an entire course by itself so I don't want to do that to you so um so the idea of creating a recursive function is that it must have a case that returns a value without performing a recursive call otherwise it's worse than an infinite Loop it turns out infinite Loops you might recall are these these wild Loops that just keep going and going and going but they live in their same same space like the memory isn't getting bigger they just keep doing the same thing over and over again the cycle never ends but there's no more memory getting added to the thing recursion on the other hand it keeps making copies of its own uh space for its function to live in so if you do that infinitely you're going to blow up your computer not really it won't explode but it will run out of memory and you're going to get a different kind of err than you've ever seen like a stack uh stack Overflow error or something to that end and actually that's what we talk about just next but um the idea is you uh when you're writing these things first solve the base case like figure out how's this thing ever going to end and then you write the recursive case to say how is it going to get to the end so in our factorial example that we talked about a little bit ago the base case was one right you know because we're going you know 5 4 6 3 2 1 it's always going to end at one um that's what factorials do that's by definition right so when it gets to one that's the base case and then what we're doing from there is we're saying how do we get to one well the idea is we're taking the current factorial times the next factorial which is the current factorial minus one and eventually we'll step back down into that um yep so here I just a little bit about stack flow stack Overflow same thing I just talked about it can really get away from you uh recursion um so the idea is that you kind of think about what you're trying to do before you write these things and think about okay is this going to go on forever or even for a very long time because it doesn't even have to be infinite you can run out of room um if you just write a very large one uh you know if we made a factorial of like I don't know some just H humongous number computers are pretty good these days I can't even you know put into words a number that would beig be big enough to to crash it but I'm sure there is one and you could probably come up with it if you wanted to um so you might want to put some conditions to say hey you're a little outside of of my scope here go buy a supercomputer if you really want to solve that one um so you maybe you you'll catch it before people put it in so your computer your your program behaves a little bit nicer and then here's uh this again just in case you wanted to see that okay I'm going to bring over vs code here and uh and we'll talk about a a few examples uh again all this is supposed to be introductory um but uh the idea let me just get rid of a few of these there we go bring this over now um is that we'll we're gonna go through some uh uh some complex examples that are supposed to be kind of fun uh and then um and then I'll go through a prim assignment our predict uh read uh predict run in uh investigate make can modify sequence that we always do the actual assignment hopefully isn't too bad it's really hard as an instructor to come up with these things um that uh just don't blow your mind on a first shot at recursion um so please talk to me if any of these don't make sense let's see let's start with the Fibonacci sequence so um if you're not familiar the Fibonacci sequence uh is basically adding um two the it's basically every every number is a is the sum of the two numbers before it right so uh and you start with zero and one you you have to do that right we'll see that there zero and one and here's where we start with that so the idea is that zero and one add up to be one and then one and one add up to be two and one and two add up to be three right so to do this uh our base case is uh um that H goodness I can't remember how this one worked this is not it oh yeah so if if the um what's run count doing I can't remember exactly how I wrote this one wrote it a little bit ago but basically if if you if we're running down under one we we stop and we return it otherwise we keep going I'll have to trace this to be to walk through it uh and please do by yourself on your own uh but the idea is that we come through here and we're going to have a run four that's what it is yeah so uh we're actually reading that that's how that works so we're basically saying keep going until we get to there so the base case is we've hit the thing that the person's entering so um let's go and run this so the idea let's go ahead and grab like seven right so the idea is that we'd come through here and say uh we're starting at zero and one right and while uh our top number is not seven um we're going to So reading it we're grabbing it we're starting this at zero and one4 and then um so here's the two numbers and then the uh the run count uh in run four is what what is on the outside there and then we're we're printing it as all we're doing it and then just adding the two numbers back through um and then we're passing that through so it's basically the number the number plus the next number which will keep keeping track of the two ones and then we're just decreasing that each time this is how we decrement and eventually we're going to get from uh our run for all the way back to our our Fibonacci number uh and and that exits our base case so let's goad grab seven and we'll quickly get uh that whole sequence there so that's how that one works go and delete my ex utable because I don't really care to keep those around um and then this one uh let's see what was I doing here uh it's a Pascal's triangle but I don't think I don't think this one actually ended up being recursive maybe it did no I'm not what it does is it creates a triangle uh and you can do it recursively but I think I I'll go and run it just because I'm curious to remember what I was trying to do let's let's go like with five rows it does that right where uh each of these uh so one and one equals two right one and two equals three two and one equals three it's this triangle where everything is the sum of the two numbers that would touch it so um uh the idea is that uh like one and one would be two here but zero and one would be one and zero so there's always ones on the the outside but then you get to like one and three and it's four and three and 3 six and this is a really cool thing but I don't think I did this recursively anyway I'll move on sorry um I tried to come up with some really fun examples this one's probably my favorite the traveling s salesman problem um where the idea uh let's let's use our pin tool real quick I'm going to try to do this quite quickly uh let's see oops pen is what I'm looking for so the idea ah stupid thing let me uh let me turn on my mouse I can never do this out here let's do View and show the mouse cursor okay so the idea is we got a network right or a guy let's call it a guy we've got a city and a city and a city and the the the distances matter in this and maybe we have two here one here and one here and then like three here again right right sorry not the best diagram ever and then we got a place where he needs to end up well the idea is like how can he get here in the shortest matter so you could go this way right and let's say this is three miles you could go this way and it's two and you could go this way and it might be four and then he could go like here and here and this might be like 18 or this might be one and you can go here or here and here or here and here or here move down there and then those three could go there but he can't go from here to here for some reason maybe there's a river or something I don't know but the idea is like maybe he would want to it might look like he wants to go this way but maybe this is like 64 miles and this is like one right so the idea is to get here in the lowest amount of miles so you might want to go this way first and then go 18 and one where it might not be obvious that that's Thea that that's what you want to do well you can solve this with recursion in a lot of cases uh where you look down all of these paths and keep keep traversing the thing so anyway um let me get out of this stupid uh uh Stupid diagram and the idea then let's look at the actual the paths so um he's got his paths a ve a vector in this case so his current path is just a bunch of different cities that he's gone through and the total distance is is storing that so um these travel paths he can have multiple ones of these um and that it's a great use of a vector by the way so our Vector looks a lot like uh uh it's storing the current path which there should be a mechanism to I think it's these City distances I think that's where the current path is coming from um and then we recursively go through these things uh let's go ahead and run it and uh see yep so the idea is it's taking let's go down to so the the distances are given here so the like from Z to Z is obviously zero but from 0 to one it's 960 and it's telling you that the way these are going um and the idea then is to solve all of the different possibilities uh to get through the network so he needs to visit all the cities so they or at least uh or is it four I can't quite remember uh the point being though is you look for the minimal one of these and we can search that algorithmically Alor Alor with algorithms sorry it's laid on a Friday afternoon all right let's get into this is a fun one to study too and again I want to more introduce the problem than uh walk all the way through solving it um it takes a long time time to really Trevor this is this is a huge topic and a hard one to solve in computer science this is not the most efficient way to solve this not by a long shot there's ways to actually optimize this and search only uh only um you know kind of edge cases and things like that but it's a very s famous uh computer science problem that we can solve with um with with with uh recursion and uh it's a fun one to trace too so this is be a great one to set a trace and step into a lot and see what it's doing and and and see uh how the variables are changing and the the the uh the um the uh the recursion happens so you might want to set um like right here you could you could do something like this where and then we we just run this with uh we we debug it uh as such I think this will work on this computer so and then you could step through this so you could see here we're going to have you know basically what we're going through and I f11 here on my keyboard is going to be very handy because I can go a little faster and you can see where it jumps around to and what's going on uh oh you know I don't want to use that oh I probably want to use this because it's actually going into the uh calls where it's uh it it's um it's going into the vector code the code that's implemented in C++ for vectors but you can kind of see the travel paths as they get built out here as well anyway I digress I don't want to go that far into this I just want to introduce the problem okay let's get back out of here okay so um the first what happened to this my predict one I'll fill this back in it's a very simple one where you investigate uh I want to say adding the numbers up that are in a number so if you give it like 1 two 3 4 five 7 1 2 3 4 five uh like the integer like you know 1,200 300 1,00 1,200 or I'm sorry 12,000 345 1 2 3 4 5 it would add up 1 plus 2 plus 3 plus 4 plus 5 it's that kind of problem um I think or is that what we did here NOP this is yeah so you'll do something similar so I'll add that back in let me go ahead and grab that actually uh uh well I'll put it back in here but that's the idea what you're doing here and the um the uh and and it's a simple simple one that you'll just um take a look at and answer some questions check your understanding on sorry I've done a few of these videos today and I I kind of move some stuff around um H nope I lied this is what that one is uh so uh actually let me go ahead because this is supposed to be the same thing oh no this is counting them is this what we're doing here no yeah this is a sum of them yeah okay yeah and this one's going to count them so this one the investigate is very similar to what you'll be doing this week so what's the base case here what let's take a look at this one particular so the idea that if uh if we've got um 345 it's going to count count these things so basically if n is equal to zero um obviously we want to return zero that's the sum of the digits right uh no I don't want to sum them did I I think I messed up oh no I just I have the wrong this is the make the make uh I'm sorry I've got the wrong header on this this goes here yeah that's all it was sorry so yeah that's why I was confused I just had the wrong the wrong one on this so um I'll I'll fix this I'll fix uh the investigate one but the idea here is we're summing them instead so the idea is that if we take like 345 uh we're going to get 3 plus 4 plus 5 so it' be what 7 + 5 is 12 is what it would return um and we do that by setting a base case so if it's zero obviously um we're going to um we're going to have return zero here right uh because the sum of zero uh uh it can't go any smaller so this is our base case and then what we do then is so you this is um integer division so the idea is we're going to first do the modulus operator on this so let's say it's like 15 well modulus in in in mod modulus 10 would give us five and that's where the the the five part of it's going to come through and then we're going to call this again with the uh the the next one down which would give us the one right uh uh so this would return first the five and then the one in 15 because that's what um uh the the 15 divided 10 would give us uh 15 integer 10 would give give us um a the the um the quotient would be the um the the the the uh this expression would evaluate to one and then we would add five to to that one so the idea is that we keep going down so if it was like 126 right the uh the first one this would give us six and then 126 / 10 would give us 12 so then we'd call the same thing on 12 and it give us two and one and then one um and then eventually uh you're going to get to you know like five just the number five where this divided by 10 is going to be zero and it's going to return zero and it's not going to add anything more so that's how that's going to get added up this is another great way one to trace though and this is a great also one to really investigate hard I this is probably the the one I'd want you to spend the most time with dig into this one use the Trace function uh and see what's going on with it and maybe even print out uh you know uh like maybe we could do something like this where we do see out this is probably a good addition actually see out and we'll do um like this and then this and I think I need iio stream let's see I should have one uh just this I think is what I need there to make that work right there we go so here's the idea is that we'd say uh let's do even a little bit more so let's do um I'm sorry double quotes in C++ too many lessons today and then the same thing here and let's just run this with a very simple hope that uh get rid of that should fix everything and we'll fire this thing off so let's add Let's do let's do three of them so the idea as you can see there is that we're getting the one the three first and it's coming back with 12 12's getting put into this and then our modulus is two um and uh we could even put n here actually that's let's go and do that grab this oh and then I just need the stream one more time this is a great example I really like this one it's probably my favorite one and let's do this and do like this and that should be a really fun program to run and kind of demonstrate how this thing's being done with christas so let's do 1 two 3 4 so the idea is it's coming in with 1 two 3 4 we're getting we're scraping off the four and the quotient 132 that's getting fed then to the next one where we get two off the end and we're getting 13 back so on and so forth and then all of a sudden it's adding all of uh all of all of the modulus is up 4 plus 3 plus 2 plus 1 which is 10 and that is just a great example of of recursion in a nutshell you're going to do the same thing in your make program this one though instead of adding those together you're just going to count them uh which should be even simpler than that so hopefully you can write a digit count function that does something very very simple there and the idea is more to explore this stuff this week than to actually just kill you with a recursive unit um and uh yeah it I'd love to I I wish we had time I'd love to go into the travel s salesman program or some peration combination stuff there's some amazing computer science prrs programs we can solve um and introduce you to the whole worlds that I didn't even know about till I was much older than um than you are uh well most of you uh when you're taking this or at least this far into your career but it's still some really really cool stuff so um I hope between the reading and some of the material and especially this last the modify uh assignment here that this is becomes useful for you um and something that you can build upon so anyway let me know if you have any questions I'm sure you will this is a tough tough unit um we'll build on this if we go into trees um as we as you saw with the binary search one that's another fun one uh but please let me know uh if you when and if you run into problems something that I'd like you to have a little bit of a grasp on um this is probably as abstract as we get it's a it's a bit of a head scratcher this one but it's a really cool way to solve some really neat computer problems uh in in the modern world and it's it's been that way for a while computers do this really well um and it solves some neat problems so anyway thanks um and good job if you got through this and you understood everything um if you didn't please come find me talk to you later