hello welcome back to the uh unit or the the the the part of our course where we're going over abstraction this uh this particular bit uh is I'm going to try to turn on my camera here my face is getting a little bit better and see uh just move that up here I just realized I didn't have that on and I think I can do it now yeah my face is a little droopy had had something happen this year uh hopefully by the time uh we get around to using this course uh this will all be cleared up and and when I'm lecturing it won't be quite as awkward but enough about that um the uh getting back to abstraction though we we studied uh the ideas of um code blocks a couple weeks ago and um with wild loops and things like that and our our that was our real first jump into using our control structures to to start to um you know separate our logic of our our programs from our uh from from our data or what we're working on basically uh we use the unit the the analogy in the functions unit of bringing the tool to the job right as opposed to bringing the job to the tool um uh and hopefully that went well uh certainly if things uh are are still Shady or shaky um Let me let me work with you uh please get a hold of me immediately uh if you're still on Shaky Ground because we're going to make another big jump this week actually uh in the next couple weeks um this unit is probably the minating unit probably the biggest biggest uh step forward will make as computer scientists in this class um everything else uh from here on out will be utilities um or uh or or or uh uh we'll we'll build on the concept that we're building on right now this abstraction idea uh so there will be a uh um uh this might be broken up into several weeks I'm not quite sure yet but uh I'll show you I'll tell you why and where um but there's only going to be one assignment for it so just one real uh Prim cycle where we do the predict uh predict run investigate M uh modified make where that you'll turn in the make and it's actually a fairly light uh assignment so hopefully you'll spend a I really want you to spend a lot of time conceptualizing and playing with code that's above the level of what you're going to be using As a matter of fact before I think or forget about that I am going to add a discussion item right now uh because the main thing I really want to do is um um talk about the I or get to the point where we're using did programming the final right we're we're getting to that point where we need to start thinking about that thing as well um it turns out that what we're going to be doing this in this unit is just a great tool for implementing um the final in um when we're doing um some of the uh some of the more advanced things um now in in some classes I use a uh a lighter final where you don't necessarily need to go all the way to objectoriented programming uh programming I usually use that in 1010 um uh so you you don't need to go this far with that uh this would be an optional unit in in CC 1010 but in uh 2409 for example this this is something to study quite a bit um so going into the weekly or the unit uh homework and overview uh this is very loose definitions right now we have a very good very good unit on classes in our zybook um me I I uh will uh this side book needs to be updated they changed the title on it I was using 1010 the 1010 book for both but they've actually switched them for for our different classes uh regardless the unit Remains the Same this lecture Remains the Same for both and it's the same material it's just just the title there um so that'll be here uh and then um this video will be linked here um right now this this is a completely broken link um and then the uh the other lecture uh that I'm going to link is in Python's uh or Harvard's cs50 class you may have heard of it I've referenced it a couple times it is actually kind of the inspiration for a lot of the way I teach this class um this is a three-hour video but it's a great one and if nothing else I want you to have it in the back pocket frankly um this guy is world class and um has been doing this this very topic for years um as opposed to me who's kind of dabbling in Ai and things like that don't get me wrong this is gonna be good I'm I'm doing a good job for you but this is better I I'm not too too proud to admit that this guy's stuff is great it's just three hours so I didn't want to use it as the primary lecture and I wanted to tailor this to what we're doing and frankly um I'll be stealing parts of that maybe even next week I might even make another video of that of this I've really tried to pair that back though into what what what you you can use right away here and then finally um I'll reference uml Universal markup language as a New Concept for diagramming and thinking about programs this is just a nice link of a tutorial on that we're not going to jump into that it's a little bit beyond the scope of both of our classes here it's more more uh akin to like a software development class or a 3,000 level class um but I wanted to I'm going to I'm going to use it as an illustrative purpose or for an illustrative purpose in about two seconds here um and I wanted to give you the uh the the material that that you could use for that it's really cool stuff um and then the assignment um as we talked about is the prim stuff you know very similar to what we've done in previous weeks you'll download the assignment here extract it open with code in Visual Studio code um go forth and do some of the uh Le you you can go through the lecture stuff that I'm going to do here in a bit in Visual Studio code as well uh but the other thing is the the make assignment which is very simple you're and again this is this is a class uh this is objectoriented programming you'll certainly I I actually hope before you even watch this video that you understand the differences between like what we've been doing with with functions and and even like lists and array or uh lists and and dictionaries and classes that should have been you know done in the reading um but uh you'll be building a very simple class with some very simple methods this is more just kind of a checkpoint though um uh we'll we'll be hitting this a little harder in the coming weeks um a little bit and just a few points that I I always try to write down a few things that always go wrong with these things so make sure you read that it'll probably save you a few uh a few cycles of stress uh as you're digesting new material uh let's see so I'm going to go uh to my PowerPoint cool that actually worked uh and do a little lecturing here uh just on high Lev Concepts and then I'll I'm going to jump back and forth a lot um and end up I'll end up reinforcing this a lot uh in my uh in my with the code here at the end so I'm going to try to be conc prise but uh to the point and uh I guess I should probably make a note and let's see if I can get the camera back on um I kind of like like having it back as much as my face bothers me right now um I think it adds a bit of a personal touch to it and I I do like doing that for you guys um so here we are uh oh sorry um object-oriented programming especially in first and second year classes is a lot it's a lot to think about you guys have come so far and I'm very proud of where you're at at this point in the class um but there's a lot that it's very hard to lecture on in the a limited time frame we have especially if if if we want to leave room for things like some of the exploratory stuff that are a little more fun um that I really want to get to in both of our python Pro programming classes right now um so that being said what I've done is I've really molded on this for honestly months um of what to do and how much to present and not to overload you but give you the background that I think you need and all this stuff um please know that this is not going to be the the the last time you'll see these Concepts um I think the books does a pretty good job really that video does a really good job too the other video um but I've tried to pair it back like I said to a few things I just really want to highlight for like a I hope it's less than an hour I'm hoping like 40 minutes we hit here by the time I get through all the code um we'll see how I do um and stumbling through these things as I tend to do uh with with that said um again I'm very proud of of where you guys have come and I really want to emphasize and and it brings me to my oh you know what let's uh where's that reader thing yeah there we go there we get it full screen make that a little more readable so let's talk about our abstraction Journey um you know this word abstraction as as as you hopefully know by now is the idea of taking taking making big problems and breaking them down into making them little problems that we can then start to work with uh work work with um work with the smaller Concepts in isolation perfecting them and then putting them away and not having to worry about that implementation anyway right so you know if we were trying to do something like um like uh print this you know um get um I think I think the example I stole here was actually from the cs50 video uh he's doing um uh Harry Potter here so this program might be a way to take you know who's the N who's the wizard The Little you know the this the child Wizard and the house that from like Gryffindor and Ravenclaw and all that and then it might print something like this right well we could do this over and over again and collect data and and even use some of our intermediate data structures like you know a dictionary would make a good good good housing unit for this right where we do this over and over again or we might put it in a wild Loop or we might start to put it in a function right where we do things like you know Define things like get name and and and get house and start to collect these things in a more programmatic way so like we talked about last week uh if we want to change the prompt we could change it in one place right um one thing I do want to introduce that we haven't covered um it's it's a great practice though in Python um and I think we're to that point now is to kind of even modularize your main program so what you can do in Python I'm going to take a drink is you can define a main function and it works just like every other function it happens to usually be a fruit a void function an output function it it's got a side effect right we we studied that last week um and then the the nice thing about that is as we move into more and more complex projects we can start to put our code in other files we're not going to cover that today but you can do that and it's very very nice because you could have for example all your program or all your graphics in one one place and all your data manipulation stuff in another file where you're maintaining that on one file but then you have a main file that's actually the thing that's run so if you running it in an interpreter or like when we send our things in visual you could type python main.py or Main program. py and that main program might look something like this uh where you define main here here um and then you can do this this little bit of code down here super useful what it does is basically says if the name of the uh um level of execution I'm not going to jump into this too much uh let let me jump into what it does basically it's saying if you're running this program run this run this function this one called main um if if if you're calling this from somewhere else maybe that's a better way to describe it right if you're calling this file from somewhere else so if this is included in your file this doesn't get run so the nice thing about that is you can Define all these things outside of it and you can even run you can have this part you can run this file just to debug this part of it so this could be like okay I want to make sure the get name's working right so Maine might and it does in this case does some stuff with that but then when you're calling this from somewhere else it wouldn't do that you would just have Main and really get name and get House available to you it's a really good syntax I wanted to introduce um and we might see it here uh you know as we go in this class but I wanted you to be more familiar with it um and it's really useful when you're building multiple classes to include this because what you can do is run this thing one thing I really like to do is um put debugging statements so let's say I'm making a a class about a chess chess board and a chess piece well I might have a a class for a chess board and I might have and it might contain a bunch of instances of chess pieces which then would have its own class definition right well when I'm working on the chest pieces like implementing like its print methods and how how it moves and what it stores I might have a little program that's saying hey how does the the knight move and testing that right there in that in that chest piece function or uh uh file and then I would be able to just run this bit and say write some test code down here that doesn't ever get used by the main program but it's useful for testing that small bit of logic so that's a really nice bit of abstraction but anyway back to the main point sorry I've been meaning to do that for a couple weeks now um and we might cover it in in an optional files and modules unit that I've got designed I just don't know if we have time for it uh and we'll really jump into that if we need to the point being though is we we've started to move into moving our code away from line by line procedural stuff where we move it into functions where it's reusable but we still can do a little bit better um oops H sorry uh where we yep so what if instead I told you that there was a way to bundle the data and functions the data and functions of an entity or an object into a package that then is modularized so think about a function it's kind of got its arguments and some code that works with it well what if we can take that another level up and build a bunch of functions and and things that are related to each other and package those up that's the essence of objectoriented program that's the core concept there and we do a lot more stuff with it there's a lot of cool bells and whistles but the idea let's take a rectangle example is we can I'm sorry a length this is a let's call this a line I think I'm going to use a rectangle function here in a bit um over here on the right or left um the this this is just a number this could be a variable and then we could have get length and set length right so the idea is that the the the the person behind the scenes deals with length and in this case it's just assignment it's pretty simple but if this was like some crazy set of complicated functions or maybe even multiple functions um to to set the length you could abstract that away in this container called a a class and and you could use these things to say uh get length and set length we see this don't we we we've seen this before where we've created things like um you know small objects uh and and and use some some properties on them and all that's doing is saying you know within this when this this named thing we have this thing called an attribute which is just a variable in most cases um that's describing it or giving us some useful information about it and then we have ways we can interact with that or they can interact with each other things like that where that becomes very powerful is we can start to do that on multiple things so I grabbed a fairly complex uh diagram and this is the uml I was talking about that's that's this this syntax um where you have many you you could say okay I'm going to design a customer where it's got a name and an address and an order has a has a customer to it usually and orders have order details like lines of them and Order details have items all these things can be abstracted away the the the the in like get tax here that might change all the time based on tax laws so we have a nice way to update this where it doesn't affect any of this other stuff um and then we can get into like Payment Processing we might include credit cards and things like that and the idea though is we break this down to simple pieces and then we do it right and we put it in its right place we test the heck out of it put it on its shelf and then it works for us and then we don't have to think about it anymore and frankly that's the best part we don't have to think about it anymore we put it put it away and do it like if I had my stupid Tool uh pictures you know I don't need to know how my table saw works I know that I can click that button that might be a method it clicks that blade and uh maybe as a method to keep your fingers away from the blade silly but I know I can run a board through that and it's going to do that job I don't need to know that about three- face power or the kind of blade in it or anything like that I can raise and lower the blade I can turn it on and off that's all I need to know about it maybe change them you get it um same thing here um that's really what we're building towards here so this is a way to kind of conceptualize and it's about the best way I could think of other than the code demo we got a cool demo cool codee demo coming up with it uh that I I put together last weekend uh where these things play together and that's the idea of it all this is really where uh programming turns into development or software development U we see it in all aspects uh let's see so taking a step back from that I I know I introduced the idea of classes here but it turns out there's uh you can do this with with tles and I'll do a little brief Cod on this cs50 does a great job of this we can start to package more stuff into a function or a dictionary and use use it to pass around in functions and you'll see there's a lot especially in data science of a a feature of python um uh called tuples or tupes I think they're tuples um uh it's very useful and you'll see it a lot in data science it lenss itself very well to that uh GIS if you're work if you studying GIS you'll see a lot of points in in in a tupple just an XY coordinate instead of so just it's so um it basically you know packages a series of variables together so in a tole it's like a list but it's immutable they call it and I I wrote a little bit about that here um the reason reason it's immutable is um it protects us a little bit it protects us the reason they're used so frequently with it in in hand inhand with functions is it's a great way to get more than one value out of of the thing out out of the function um so let's say you're you write a function that's dealing with um an X and y-coordinate on a on a on a map you write grid GIS application here um well you could certainly write X you know and Y and then you could write aun fun to take X and Y and doe distance or instead you could use a tle to just pass in X and Y at the same time it simplifies it this is not possible in a lot of languages um this is a concept that's kind of really you can do it you could obviously you can build anything you want in any language right um but it it's a built-in thing excuse me in Python and it's really one of the things that uh really makes python nice is it's just done a lot built in for you that makes life just so much easier um you know being a modern program programming language you'll come to appreciate some of these things if you ever go back and study like C or C C++ or Java even Java Java is notorious for kind of some painful uh moments like oh this should be simpler well guess what python is that's why we like it um and that's why it's kind of been embraced in in in the Modern Age of computing let's see here um yeah talked oops uh sorry uh but yeah so the main main main uh Point here and I I'll demonstrate this a bit I'm not going to spend too much time on it it's cool it's fun stuff uh but is that uh TPP uh tuples tupes tuples uh they they basically look like they're returning more than one value but really what they are and it makes a nice segue into what we're doing they're an object so it's only returning one thing it's just an object that contains more than one bit of information make that distinction though it's very it's very important and we'll study it if you can understand that I think it's going to help you bridge so instead of like a a a function returning a number it returns an object that contains two or 10 or 20 numbers in a toule same thing can be done by the way with dictionaries if you need to mix types or if you like the naming right or if you want to be able to modify these things after the fact dictionaries are a little higher uh Power uh they give you more power at the uh expense of Simplicity and um a little danger you could overwrite things in weird ways uh when things are mutable versus immutable um just some things to know about that um but yeah I I uh like that let's see okay I think this is kind of self-evident at this point um but one thing I wanted to point out with this slide and not going to read the whole thing I want you to think about operations if you think about going all the way back when we talked about assignment where you know things happen on the right and they're assigned to the left everything happens to the left right this is an assignment operator as you well know by now I'm not trying to be pantic about it but the idea is that this is this is holding some variable well this variable does not have to be a number it is in this case right where it's taking y + 27 doing something with it right well so y would be a known thing it would do this expression Expressions right where we we calculate all this stuff out and then store it back into X um that's uh that that you know kind of well known by this what about this kind of diet where we got I'm sorry let let me me let me let me edit this let's see if I can let's I just want to put this on a the the reason I want to do I just want this on a new I want this on a new line like that um just for that uh and then I'll go back into reading mode um where there's no difference uh so this is an operator this is a method in a class doing something like Plus it's doing something and it's taking two arguments and why in 27 become player one and player two just an operation storing the outcome in a variable this is not uh this is not too much crazier than this really conceptually right now don't get me wrong how this is implemented a lot more complex well at least conceptually you know may maybe this is simply the same thing maybe we're just adding numbers together for all we know but the point being is that we're taking what we already know and extending it to use more powerful tools um I want to bring back my my screwdriver slide right now because power tools are fun anyway moving on let's talk about the anatomy of a class sorry about it's December here dry throat you may SE drink as a matter of fact that's a a great um kind of way to talk about a class if you think about when we talked about types very very early on we talked about numbers integers right you know numbers without decimal points and then floating points numbers with decimal points and we talked about characters how they're encoded in binary and how a bunch of those can make a string right start to build these things up a class is just taking that a step further and it's combining binding it's combining um uh um basically a bunch of different primitive types or other objects you can scaffold this it doesn't have to always start with numbers of letters you can build objects upon objects and even inher well we'll talk about that another time um you can you can start to build these up as we saw to build more and more complex things um one thing that's uh so uh let's let's go ahead and take just a sec it's a blueprint it's a blueprint of of your new data type and by data type I mean or abstract data type is what the reading will use and what you might see in other computer science classes a a uh uh a ADT ADT abstract data type as a conceptual here but what we're doing here let's use rectangle so by we're building a blueprint and that's all this is I'm going to quiz you on this a couple times during the the the the prim exercise uh but it's key to know that all you're doing with the first part um above my cursor here is building a blueprint we're saying that we are going to have uh something called length and something called wi and we use this self syntax to say the this is this belongs to a rectangle that's what self means and you need to use that in most most of your functions because it tends to it tends to uh python uh allows you a little more freedom uh to um allows you a little more freedom to be able to uh do things with classes that you can't in other languages um for security reasons and memory but to do that you have to pass it to itself that's what self means here so just get in the habit of putting this with your functions you'll see it uh when we study it you almost want to put it just about everywhere and it'll make more sense in just a bit um but really the way to read this is that we're giving we're making a new rectangle class that contains nothing but two variables length and width probably numbers right so then we can create an object from that blueprint so we create objects from classes think of class is a blueprint and object is the thing that's actually built using the blueprint um you can also think of that as an instance of a class and what happens when we do that is memory gets set up just like we talked about for bytes and numbers and strings it gets set up to hold that structure the other thing though that classes offers is a place for methods or functions within that class to uh operate on that and they they get their own own copies as well um and that's what we see here so um one thing about this word a nit this function might look a little funky here this is called a Constructor Constructor um and what that does is basically give and you can have multiple versions of this by the way so I could well so the idea of this is it's basically taking it's a function when we set up a rectangle it says so basically this AIT function when I call rectangle when I call rectangle it's saying take this class and pass these objects or these these values to the Constructor to set it up hence the word Constructor think of this as the setup code it's it's basically the the how to set it up code you can take things in or you could just give it values you could put one and 11 here as well um and just say that's the default one and in that case you could get rid of length and width um that's often done so you'll have two Constructors it's called an overloaded Constructor at that point where one would take length and width and you give the the the programmer down the road the option of setting that but you could also give it a defol value says just give me a 2 by two one because I don't really care what it is I can use methods down the road to alter it for example um very common stuff there and then we could print it so we can go in and basically get parts of that with this dot syntax which then gives us access to length and width we you do the same thing with methods by the way this is how we call methods so once we create these so rectangle one and rectangle two other than their name other than the fact that they are a rectangle have nothing to do with this those are just variable names at this point or object names let's call them objects now I think we're to that point because variables kind of mean one value objects mean a bunch of things so the object names here rectangle one and two are object names that are then in memory right now they have the structure of of the Big R rectangle and usually that's a good naming convention to get into habit of definitions usually have big big names big big uh big capitalized names uh instances do not so instances of objects come from class definitions this is a tough concept I'm not going to beat it to death here this is one of the things I struggled with I want to beat this to death um I think that's all for the lecture let's just make sure yep nothing else in there okay let's go to some code uh let's go to some code there we go uh let's go to some code what happened to my code there it is okay so this is what you'll be doing we'll come back to that actually let's start with that um the actual assignment will be uh I'll come back to it uh let's uh close all these out for just now sorry um I've come back and forth okay so in this case we are going to be playing with accounts and customers um one thing to study here is this first idea of a method in the class we haven't seen this yet so just like um a function we we start the word with a class with the word class instead of defa and then we give it a name again uppercase because it's a new type colon and then this will all be indented just like functions just like if statements just like well statements we usually by conventions start with our um a nit function and that needs to be defined like this this is a reserved word in python so you'll want to give your Constructor this a nit underscore underscore uncore a nit underscore uncore the word self and then optional things that we want to pass to it this case we're going to give it a customer ID and a name one thing to be mindful of this customer ID and this customer ID are not the same thing this customer ID because it's being called by self is the internal one the one that is owned by the one that's owned by customer as a matter of fact I usually like to do this I this isn't a convention for anybody else than me but I'm kind of an old guy and I forget things sometimes so sometimes I like to do this when I'm writing my functions I'll give it in just to keep these things different python doesn't care except for the fact that you'll want to call it in customer name when I use it later so I'd want to do that down down here now actually I'll leave that for a sec I'm this will break um but I'll show you in just a sec but the idea here is that this maps to this so the path goes you know it'll come from here through this just like a parameter does to a function into this and then it's assigned to the internal customer ID so the internal customer ID is called customer ID um the internal name is called name but the inputs to this function have that in and I won't do that again but I just wanted to illustrate the difference there as we're talking about how these things are set up so then we run it you need to have the code run to uh run to to know how to define the the um the the the class before you can actually use it um so in this case it doesn't do a dating thing down here we might might have noticed that go so all it did is it took took this and did nothing all but it knows it knows that that's a definition now um very there's that'll happen a lot where you won't get an error even if you make mistakes until you actually try to rent the thing we'll see it in just a sec actually you'll notice that exactly what I said would happen happened um because it's expecting in customer ID in its Constructor it's look and I assigned it customer ID so if I would have done this like this it would actually work because you can pass them oops uh you can pass them you can pass arguments by just their location that's fine that's fine as a matter of fact we can even display that right that's what we want to have happen but let's go back uh to this and the the reason this didn't work is because the The Constructor was expecting an argument called in customer ID instead of customer ID I just because I changed it so let's go ahead and make Bob here let's go make B we'll just copy all all this because we're lazy and that's what good programmers do let be lazy to the extent possible we'll make this one2 we'll make this Bob Jones oops and um and then we'll say this now you'll notice and this is really kind of uh I hope click sorry I hope this is starting to click that these are different things these are completely different uh objects that are using the same blueprint what' I do I did something wrong name well I know Bob's not defined I'm defining it what did I do here uh oh I did exactly what I said I wouldn't do again all right there we go this should all work out there we go um yeah so uh what I just did um and this is a good example of debugging um uh it's called refactoring when I change variable names it can be a pain there there's some tools to use it I'm not going to get into that probably even in this class um to help you rename things smartly it actually follows the traces a little bit better than maybe you might uh be able to do by yourself uh but some important stuff there all right let's move on so we might have an account here that we want to take a customer right this is so we start to pass these things to each other um in and it's and an account number um and it might do some stuff like deposits and withdrawals so that's exactly what we're going to do it takes a customer though and sometimes it's even worth you know python is very forgiving with its what's called typing it doesn't necessarily know that customer is a customer object but you might be acting like that and especially when you start using it as such you might want to make references as you go um you know as you get better at programming and you look at a lot of people's code you'll you'll know that this is probably you know a custom class especially if it's defined right above it um but it you know keeping those things straight can be tough so uh do yourself favor add comments so we're taking a customer as defined above that again has name and all that encapsulated away now though we don't have to worry about it anymore we don't care about how the name and print method are set up that's done we trust it we're moving on so we just use it now and then we get a number and this is just a number um but we're going to add some stuff to this account we're going to add the ability the method to deposit into our account and we're going to withdraw have the ability to withdraw from our account so let's go ahead and run our class and again we're running our class not to do anything with it yet we're running it to basically give python the blueprint of what we're doing and you can really I hope this really clicks right now for you guys I hope that this is the point where you're like okay now I'm creating an account with a customer called Alice so there's a new account number and um and a new and an existing so we could put Bob in here couldn't we or we could Loop through millions of these and do things with it um you know but the idea is that this customer idea is modularized and uh we'll see we can just peek at what this might do it does some simple math just like we would expect and um and and then it prints some stuff out so let's go and try that so we could do this method we're calling a method on this new account called deposit in this case we're going to deposit a th000 and we see that she got $1,000 now the cool thing about this is if we run it again now it's 2,000 it's it's maintaining that balance in the background of account for us we don't have to maintain our own variables for it and we get one for every person so we could do the same thing with Bob let's go do that let's go and do Bob it'd be very easy to make a mistake in procedural programming and say uh sorry I need to make a bob account let's go and do that we could uh easily make the mistake of uh mixing up whose uh accounts are in whose whose places because we've got a guy named Bob we could we can make an account for him and we can deposit of Bob now you might recall Alice now has 2,000 if we give Bob a th000 though we see that it's completely separate different instances of the same class so Alice got run twice and let's just let's go and run Alice withdrawal now right 1,700 Bob still has a th000 if we don't have a get a get uh function here uh we could add one uh let's let's go and do that just make that a little just a simple new fun uh new new method in here um let's say get balance and we don't need an amount we're not actually doing anything with it this is a method and the only thing we're interested in doing is printing so we're just going to strip out a lot of our math code get our indent right and do something like that uh and we don't need the withdrawal because it's not there anymore so we can again update our our class and this is another very powerful and by the way these get handy where you collapse things uh might want to play with them I can rerun all this code by the way just by doing that after I know it's good or I could have blocked it and it even blocks it up for you um so what we're doing now though is uh so let's go ahead and see uh just how Bob and Al Alice are doing so let's go Bob account. balance and we can even see auto complete is smart enough and Alice account we can start to see that our tools update and they know things about these things and we can find out just the balances of the two and of course I broke something uh what did I do what did I do with this I I thought it was simple enough where I could get away with it um coding in real time oh it's get balance so what I did there is I actually called the the balance variable uh or or attribute as opposed to the method bad bad practice you shouldn't most of the time you want to use um and we'll talk about this Setters and Getters and this is a good example of a getter where it's using a function to do something with it um you could actually return the balance as well um and if you need to manipulate things it's just good practice because it gives you a layer to manipulate code if you need to for example if you didn't want to alterntive was lower than zero you could basically handle that in your in your get and set code which are just methods called get balance and set balance in this case um it gives you a place where it's not just a variable you say instead of just going to it you can you can have some methods and then you return it you return the method from before and there's actually even ways to protect it to make your classes have to do that it's called private and public uh uh permission levels on on on things um but again beyond the scope for this introductory unit so uh let's see oh oh yeah I want to so let's let's go ahead and finish up what we did oh did I did I not rerun it uh thought I already ran this let's let's go and do it again I must have messed something up guys I'm sorry let's make let's let's give it one more chance oh you know why it's because I created this a I updated the thing this is actually still using in memory the old object model so that's a good good indicator to let's let's go and do all this again because now this is getting the new object model so th these didn't update automatically with the new blueprint great example right of of of just because I update the class I have to I actually have to run the code to do this I'm guessing this will work for us now and it did yeah so that's what happened there kind of an interesting thing I stumbled into and a nice thing you'll struggle with as well especially as you debugging code um the last illustrative uh method let's see where we at on time on this sucker uh 43 minutes okay I'm going to try to go a little faster here um because I really want to get to this last part H we might be an hour on this one um transaction this is another class where we're modeling moving things around between things you can do this within you could say make a method like send to another account or send to another customer you could do that but you can also use these kind of um kind of classes uh where it just basically says has a sender and a receiver and the these are both accounts in this case um and some methods to say you know that uh um it's moving things between them and it it's a nice way to uh put a lot of logic into the the idea of a transaction as opposed to saying a transaction is a method of a um an account which it is but these things can be related and you're not limited to just saying so you what you can really do then is boil down just the things that need to be an account in an account um and uh and all this is doing is really moving things between two accounts as we see the Constructor has a sender and a receiver those are both um accounts and then the amount is is just again the amount so uh um let's see I think I did so I actually for this I had actually made another guy named Bob when I wrote the code uh what did I do oh yeah and I made the same mistake again uh uh customer ID see this is what happens when you code on the F what I do to customer I need to remember what I did to customer it's in customer ID it's in customer ID um so be careful when you change change names you can run into this so This should now make a new Bob Smith it should but it didn't oh in in name same thing same thing it's amazing how you'll make the same mistake and think you've solved it and then you just need to do the same thing again and uh Bob account gets a new account and then what we can see here is this transaction we'll do that and then when we execute it it's going to call this so it's set up now it's got a sender and a receiver these are set um by set up by the Constructor but then this execute says do something and this is kind of cool right you could separate when the thing's done to like when I don't know close a day or like within a credit card window so you avoid paying fees all kinds of reasons to move this away from the set the setting up and the the doing right it's very common um you'll see that a lot in game game game programming as well then when we execute it you'll see that they moved and we could even do the things that we talked about where we could say let's let's go let's go and do that let's do Bob count dot uh get balance let's do that and then let's uh do another transaction just like we did then let's do a bob account get balance and again if you want to you can use code completion the nice thing about these is uh you um you built a new type it's in Python's kernel it's memory for lack of a better term and it knows what you're doing at this point so we can see the Bob um uh had 200 and we transferred 200 from Alice to Bob and now Bob Bob has 400 so kind of kind of a neat way to work with several objects pixel once okay I got one more example uh yeah let's go and save that it's not too bad code's not terrible of game development um let's go ahead and grab this guy and by the way there are markdown files for all of these I made uh when I was building this so you can kind of see what's going on a little more descriptive things like that so the other uh thing I wanted to illustrate and the reason I built this this I'm going to grab two bits of code here uh can I well that's weird let's just do that not quite sure why that does that like that um so let's let's pretend we're we're we're building a game um and I'm not going to go over all the definitions here and things like that but we're basically taking in um a name for the for a character at this point a character in a game not necessarily the hero or the player but just a character um and then we're going to have um some numbers that represent their hit points their magic points points apologies to you non- Gamers out there I know that might be a foreign but basically they're they their numbers saying how much life and power power do uh does this player have you know if you if not into that inventory is actually a dictionary or it will be um where it stores a bunch of things like their clothes and their swords and stuff um and some other things I'm not going to get into the implementation but the idea is we're storing a bunch of data that would make a game work and then we're going to have this display info this is called a base class so I'm going to run all this you you can see the Constructor here um to the point where we can get uh let me clear this out where we can get to where the class is defined we create a sir lanselot guy and he displays it so the other idea I wanted to incorporate here amongst others is this idea of inheritance you can take this class and use it as a a base that then you can add more to it and you'll do this in your assignment so you you we've got like some highlevel stuff that every character in the game would have then we got some more stuff that we add that a player would have um including a few dictionaries here of some attributes like their strength and stuff that not every character has in the game but this this type of character does so you can think of a player player is inheriting everything that character gets everything that character gets it gets but then it's going to add more to it there's a lot more to this this is a big concept um you can actually use you can rename things or I'm sorry use the same name so if I for example use display info here and make made a display info down here it's called polymorphism it actually says okay you've got a base one but I'm extending this and doing it differently that's unique to this class but everything else stays the same so we we build a base if you think about um oh boy I just can't think of a great example that's not right in front of me here um I'm sorry I'm I'll have to come back to that or maybe that's something we can use for the live lectures but the idea is that we take a base and we take everything in that base and we get it all again and then we um and then we add to it and you can just do this forever it's so many benefits um where we could you know let's say we we didn't want to implement print in every sing in every single one of our game objects and we say we've got 50 different types well we might build this display info at the highest level and then down here you might notice there is no display in info in this class but it gets it from up here well if we made you know classes and enemies and everything else they all get this and it will you can like Loop through all these and do print info on all of them and it gets it from its Base Class and you only have to implement that in one place and then you just change the things or add the things that you want to change in the in the in the sub classes so the way that works the way sub classes work is if you pass the parent class this isn't character like strings this is character like the class we made called character if you pass that into um the the players argument it says base it on that inherit from that it's done much differently in other programming languages but they all have it and then we add some new stuff including a new init um so this init um has an armor class version this in it has a whole bunch of other things right now one thing you'll notice here we can call the parent Constructor with this super function we can call it with a super function so we can take everything we want including names like this is kind of a cool bit of code I'm going to leave it in here it's called game. py and play game player combat. py um where you can actually just say hey give me it right now I don't want to make a whole new method for this just give it to me right now and passes that up to here fills out all this stuff and then we start to add a few more things for this class like um some values and things like that I'm not going to go too crazy with all this uh because I'm getting a little long in in the tooth on this um but the idea though is we add some stuff like leveling up um gaining experience um and things like that to this and I'll let you read this on your own time I'm just going to run it at this point instead of explaining how the code's implemented um we've covered kind of what's going on and we can do exactly what we did before we create a player and I am going to say my name is Sir codes a lot like that and uh now we've got a player and I could even do player do it's not going to autocomplete wish I would down there oh we'll do we're going to do it in just a second anyway um but we could start doing this like where we're going through a game Loop we might start doing things like this where hey we we killed something and got 50 experience points and we we're again and maintaining that within and we've got that logic I'm going to go all the way here and it's currently level one and that's about all we've handled here but you can see how that works and if we've got 50 characters or players running around all of them would have their own sets of this and it keeps it separate so we don't have to say player one experience player two experience player three we just we we have these things and they're all encapsulated and we can look through them um I'm not quite sure what I was doing here let see what I was doing um leveling up experience I think I just wrote the same thing twice not quite sure why I did that that's okay I need I need I need to move forward anyway the last thing I really wanted to illustrate um is everything we just did so nothing new here I just put it in the code again so you could do it and very similar stuff here uh we're inheriting um the difference here is is that you will see this attack function and I'll come back to that after I run it where it's got a Target this target is not a keyword this is actually another it's an enemy in this case we made an enemy and the enemy is a character or it takes a character so let's go ahead and make our sir lanc aot again an evil Goblin and hopefully by this at this point everything that's happening in the Constructor you should know is just getting past to the object when it's created and filling out all the all the Gory details that we need and we can see here that hero can attack enemy right 10 10 10 10 I don't know yep and there he died yep I I I did Implement that I I couldn't remember if I did or not and then we could we can actually you know at any point we could have done this this could be the graphic by the way uh you could pass a graphics driver to your object and say Here's how to draw this thing on the screen you need like an X and a y coordinate but that's the essence of kind of how you start to build these things up okay thank you um again I've been mulling over how much and what to go over with all of this for weeks now uh the assignment is much simpler than what we just did you will uh run this and see a doc speak or oh I gave it away uh you'll go through and predict is the dog going to speak or not uh I want you to pay attention uh to what the class definition is and what the instance of the of the object is here it's really the point of that one investigate extends that just a bit um I've written some code and some questions um uh just I want you to answer in your own the head um really this is a great checkpoint in your week to say am I getting this did I answer those and it was just or was it not if it's not let's talk I'd love to play with some code this is fun stuff for me I know I'm kind of a nerd uh you'll modify this one um I included the investigate part and I just want you to uh um let's go animal types so this does get back into inheritance um you will be basically adding this and uh I don't necessarily want you to say make another bird make a fish do something with swimming here change this to swim see how they call differently see what works and doesn't work um on the different parts of up here that's kind of the whole point of that and then lastly you'll do your make your make this is actually very very simple class U I'm only ask asking you to basically go through stand up a class where you build two methods the functions of which are given at the beginning this is right out of your zbook by the way um and uh and then use this main method to to uh to basically run it so when you're done basically you just need to fill these two things out see how the whole thing runs and that's what you'll turn into be so that's the week on object or programming this is a ton of stuff it's a challenging unit and it's probably the biggest platform I can give you to move forward out of this class and into a career in computer science um we'll build other things and we might spend a couple weeks on this I might do a supplemental unit I'm not sure I want to see how this is received thank you