welcome back to our study of pointers and Link lists um in the second part of of this unit of study we're going to um get into link lists um moving on from pointers uh that we studied recently uh this week should be fairly light on new material um the concept uh is basically an extension of what we do with pointers and as a matter of fact the reading includes uh link lists in the pointers unit um we re reference that here and that's what you'll see in this guided learning it's very very small though this should be the lightest reading you'll have to do in the entire class um in the uh in the overview we'll just reference that simple guided learning and then I do um uh I reference just the um just the uh linked list part uh that's broken out from here um you'll get some points for that so make sure you do it make sure those working and if they don't let me know um I so far I haven't built this out too much because um link lists in particular are more of a hands on on exercise there's a lot of great references out there from like C+ plus.com and things like that that I might add to this uh between now and the time that we take this unit but I did find one really interesting um video uh about the Creator or from the creator of C++ on why not to use Link lists anymore but basically um let's go and get into our our um our our overview here and I might have to move my window here let's see which one might be better yeah we'll try this for now um but the the main reason we use Link lists is they allow us to basically use pointers uh which we studied with some uh intensity uh recently uh to go and uh put put um grab new bits of memory anywhere and then um uh and then um store items there and then point all over our our physical address space um if you might recall from vectors well actually actually it's one of my earlier units um so just just a quick let's move move me here let's see which one of these might be better uh we'll go with this one and I will just move me so you guys can read these a little bit better because nobody needs to see me for this um just a ref uh you know a refresher on pointers um is is that we're pointing to addresses in memory and that allows us to um basically um kind of build a link of these things or a chain of these things that'll be a theme of what we do today uh to store um values all over our memory space as opposed to in one block as we have to do with arrays and it turns out with vectors as well um so one thing that uh well and this is kind of just a a description of what we do with a link list where um um but I'll come back to that that theme in a sec so the first thing thing we do uh with a link list is we create a pointer to our first data node so this is kind of the head node it's a special one and it points to this let's say the address is 4700 here um can you see my mouse there we go uh 4700 here um where the data is eight here and then 4,800 is the next memory location so we the pointer is pointing to the next memory location and that's where pointers become very valuable and we store six there and so on and so forth um the the the difference here is these don't need to necessarily be right next to each other and then they terminate with a null one basically saying there's nothing there nothing next but if we wanted to add you know a 6,000 or or a new thing we could maybe point it to find some loc some memory at like 6,000 memory location 6,000 um we could say okay uh this let's update this to 6,000 and um and then store you know 48 or something whatever we wanted to store now the nice thing uh about pointers is to um to insert something in the middle say we wanted something to move uh to be after six and before four we could just move um say we grab 6,000 here and we store that item here and say this now points to 6,000 and the the uh the the node at 6,000 would point to the the new one at 4900 so that you know you can kind of break that chain um and uh or insert things there but you have to go all the way through the whole chain to find where you would do that that's a downside of the thing as opposed to something that's in continuous memory um as as our vectors these are dynamic memory uh structures so we can add as many as we want um but we can also add and remove things without having to allocate it if you can imagine this is a vector though um let's say we wanted to add something here what we'd have to do then is basically copy the the new the whole data structure because you remember vectors and arrays need continuous memory we'd have to Contin uh grab this whole thing and copy to a new a new block a new space in memory where it could support all of them together and then put the the new value in and then move all of these down which is a much more expensive operation than just saying you know point to something like here and then down to here um so that's really the benefit of why we use these things um while I had that up let's see um the one thing um uh so pointers used to be even more useful than they are now um in that arrays you you basically had to tell the um the uh compiler or the program how much memory you wanted ahead of time you couldn't allocate memory um uh after the fact uh with an array you you basically you couldn't do things like hey tell me how many things you want store that in a variable and say give me an array of that size um you can couldn't do that uh that's why vectors kind of became a thing um or at least one useful you uh thing for them um um but they also had the benefit of being continuous in memory um where they don't have to follow pointers so they were also smaller um they didn't have to store the pointers they they could do things like um um uh just move you write down the block of memory which makes them a little bit faster uh at the at the expense of convenience of adding memory at runtime um so that's kind of the big point there but really the trade-off in modern programming is vectors versus Link list and that's kind of what what we talk about here um and we we've kind of hit on that but basically link lists can point all over memory where uh ve uh vectors have to be that structure has to be um in one block so you want to make sure that um uh you know if you if uh if you're going to be doing a lot of updates link list might be better U Better a little faster um I'm sorry uh yeah and otherwise vectors are usually what we go you usually see vectors and frankly that's kind of What's Done in python as well in modern programming languages and that's kind of what that video was about in the uh in the overview is that um linked lists are kind of a thing of the past a lot of the time because computer operations and moving these large things around has gotten so fast that you really don't need to control this by yourself but it's a still still a good thing to study so we will just a little bit um just a few more tradeoffs um when an array or or a vector um runs out of memory um it you need to copy all of the elements to new memory locations um to uh to to basically add more things to it like we talked about um and just like we talked about um before when you do when you uh uh create a vector um or add to it they need to they keep going so if you run out of uh continuous memory it will move the whole thing to a new place and if you need to basically add things in the middle you it can um uh it basically has to shift everything down so I grabbed this from our textbook um this is actually what a pointer would do this where the value is a and the the pointer is going to 90 um well if we have to enter c in here we um in the middle we can instead point the U memory location to 90 um and say that's where uh B is and then 88 can actually go back um so you can do that in any order um uh so the the chain would go like that um that's different than what you would have to do in a vector where you'd have to move everything out and then put the thing in the middle um so you can do it with one or two operations in link lists uh as opposed to you know thousands in in the case of a large uh you know a large Vector that stores thousands of items um just a little bit of the tradeoff there and why you would want to do that I hope that's clear um uh you know certainly come come talk to me if that's not you know if what we're doing or the zbooks does a really good job that's why we Cho I'll tell you the reason we chose zbooks is probably those illustrations that they do with memory management there so um one thing about link list though that one of the downsides and and the opportunity for me to make a silly slide here is that uh link lists are like a chain and if for some reason you lose a node in there and the pointers po into something else you can't you can't recover it right so you can't break that so you got to be very careful when you're building these things that you you don't do that um usually it's a it's not a a big problem but because they're not continuous you can't ensure that you know the things just continue like like we have in the past in memory um that's one downside of of having things uh you know being able to put put anywhere in memory but also the the the upside of that is because you can just put things anywhere um we can really make use of all of our memory available and that's why it was so attractive you know back uh you know certainly when I started programming and even before that in the 80s um where you could really make use of every little bit of memory and that's why it's still kind of in use in some things like graphic drivers and things like that today um and so when when you hear that something's implemented in C++ one of the reasons usually is is to be able to use pointers and Link lists uh to really eek out every last bit of memory um I think that's everything I had on that so let going to get into the code let me switch over to VSS code here and make sure that everything's working there so let's see that's not V code sorry one sec uh let's see the first one I want to do I think let's see which one is this I've got got several examples for you um this one's very simple this is a very simple pointer structure and you'll see I'm going to go and and and get rid of our our um bottom part here so we're creating um some initial nodes um and uh so this is there's two things in here uh let me bring up the other one um let me bring up the item node code and the main code I don't know why that's interesting there there we go that's what I wanted so this is a new class we create and usually you'll do this actually it's not in this case these are just um oh yeah no it is it is the class declaration is in the header here um so um if if we haven't if you haven't studied this or or kind of gloss over this in your GL classes unit what you do to create a class in C++ in an external file is you'll create a header file giving it its definition and where things will be and then you either provide that in the header file and it gets in inserted or you provide it in an object uh code in this case it's uh provided in an object uh file and I'll go over that in just a bit on how to compile that um but basically we're going to create uh different Constructors that take nothing or just the item or the item in the location um this is useful for some of our um some of our um insertion uh things that we'll do here and then we uh this one this particular linked list uh has an insert after and uh insert after and an end and then get next um and then some print stuff and then the ability to get the node itself um so the uh implementation of the thing looks like this um so we um we store an item which is just a straight up variable in in this case um in this case I think it's a string um it is yeah it is a string and then our next node is actually null at the beginning just like we talked about in our slide deck uh here right initially this is null because the first and last one are the same um this what's going on there um and then when we insert uh and then you can also do the thing where if it if it happens to need to know the next location if you're doing like an insert um we can do it where we actually give it its location to so two different Constructors there um and we actually see that in use here um where uh we we say we know where we want to put this so we're going to make a new item node in this case with and it's a pointer um so we're storing the memory or the the location um and uh we're going to um grab grab the um what are we doing where where's this coming from I'm sorry where is that coming from okay so that's grabbing what we have already stored in this class so it's storing this in a temporary location this is a very s simple shift operation where we we take what we already have and store it temporarily in this case it's null but if we had a memory location there we'd want to store it temporarily and then we um create a uh we we assign that so we need to have a temporary place to store our next node and then we over overwrite that with the incoming one the incoming location so this now points to our new node and then we store the location um in uh of the next one so after we after we've grabbed the next node um we we then update that to our our our our our um our our original um next node so basically you can think of that if we've got two of them and we're adding a third we need and we have a a pointer here we need to store this pointer temporarily and put it away and then point this one to here and then point the next one from uh um from our temporary one back down to here that's what's going on there sorry for my bad hand description of pointers there but that's what's going on there um and then we just store the loc we store the um the uh the item as well um and that that happens uh just with the thing and then very simple Getters and setters the insert uh at end uh is is pretty simple we just pointed at the end um these These are much simpler and then we have some very simple um uh uh ability to um print the thing and get the item from from from the uh from the uh from the item node in this case so we have a very simple loc uh application of this in this node but what what I'm going to do instead though um well actually I'll walk through the code and then I'll do it um is we've got uh three item nodes a head node a current node and a last node and we are going to ask the user how many items they'd like to store and for every one of those we're going to use a dynamic memory application here so we're basically asking how many do you want so if we add like four it would go through this four times and for each one it' make a new item node it starts with the beginning and and starts to tack these things on that's what's going on up here um and then at the end we'll just print the thing out um these are very standard structures where we basically uh create a new item node we inserted at the end in this case where we're just tacking on at the end and then um and then making the and then updating our last node so the last node is basically the the Workhorse here it's always getting updated to what was or what was last so we can tack things on at the end um and then we print through that so let's go ahead and walk through that real quick I'm going to actually delete delete these so o is an object uh code um delete that one and I'm going to delete the main one and the executable and the this thing called pointer I was just playing with some syntax here and I want to show you kind of um how that works so I'm going to bring up a console so if you haven't done this before um what we're going to do is use uh sorry about the syt let's you you'll be able to see it good enough I think here let me move my head so you can see what I'm typing though but we're going to use g++ that's what we install that's our compiler um and the first thing we're going to do is use the c um uh option to compile first our um item nodee code like so and you'll see the object get created here right that's what's going on there and that's binary code then we're going to do the same thing with our main which relies on that because of the header file that's in main we'll see I get created uh sorry let me figure out oh I forgot to put this SL o there like so and that let's clear that out I type something wrong or my I'm sorry C we need to compile it so that gets created there and then we're going to link them and we link them by doing g++ and then we just give it the names are the things we want to include so in this case item node and Main and then we want to give it an output that's what the O stands for we want to and we'll just call this I don't know uh item test.exe because I'm on Windows and it'll create our executable there and then we can just execute this like anything else there we go and we can see that we just going to do two and we'll just enter that and we'll enter that and then it just prints them out very simple um but I wanted to cover that I'm going to cover that in another um linking video as well uh but I I wanted to get through that so um one other example if I've got it up here is is it this one yeah so this is very very similar and I'm not going to go through the whole thing here um but the song node uh uh implementation here does very similar things we just store a little bit more information and we do it with the pointer syntax here um so when we create um um you know we're going to store the title the song Length artists and then the next note just like we did before um the difference here though is that uh we can insert these anywhere and we will uh and um and then we have a a little bit nicer print thing here but this is very similar to what we just saw where we kind of give it its blueprint in a header file and then um and then we implement the thing um in our in our uh in in in a in in a compiled file I've already compiled this just like I did before so I won't walk back through that um but really the main thing I wanted to show with this is instead of using um instead of using uh having the user enter an arbitrary amount of these things because if if we can just have them keep going and that that's what this syntax is doing other than that it's pretty much the same they keep going um well actually I'll just run this um so I've compiled it you can see all the all of the files over here um I think yeah it's just maybe I need to oh yeah no I made it there so I'm going to actually just run that and we'll we'll just demo demo this this Loop here real quick um for you and I'll include this in in the the assignment file as well and this is called .exe so we'll just call this um you know Star Spangled Banner uh is it I can't remember who made this uh is some guy oh length and then some and then you can actually enter negative one uh and it will e but I could just keep going or I could just do that and it prints prints these things out for us uh very simple but we could keep going and it's going to just keep grabbing memory uh for us as we go um then the last thing I wanted to go over is just the quick assignment so let me uh fire that up real quick and this is a pretty simple assignment I haven't quite wrote up the assignment page yet but what you'll do here is um first you'll uh examine this no uh this um this uh this example from the book this is uh just our example from the book so if you follow it along with the reading this shouldn't look too far into you um and basically kind of predict what we'll see here um and I wrote this all of these in one file so you can just um if you've got Visual Studio code set up you can actually just do this on these sometimes the first it freaks out a little bit for me um and I lose my I lose my uh output it's usually can never find there it is um so what's going on here is very simple uh we have our next node and we do some printing uh um in in the class itself so very simple class we implement the constructors um just like we did before that's why I'm kind of glassing GL glancing gloss cring over this sorry um and then we have a print node and then we have the ability to get our next node this is how we TR Traverse the thing so I want you to follow through just like I am right now and kind of figure out what's going on here so as we create the thing we grab the head object and then the main thing to know on this whole assignment is that we grab our head object and we insert after um so insert after means so that we grab we have our head objects we make a new object object with the value 555 and we're saying head object insert after this so that kind of reads backwards right see feels like you're inserting after node object one you're not you're inserting after the head object so as you create something you want to insert that after the object that you're pointing to that's really what I want you to understand here and we can see that when we print here we first go through and create 555 insert it after the head object then we create 999 created it after object one which we just created up here and then all we do is Loop through and say our current object is our head object and then while we're not a null pointer we're just looping through that and printing that's that's all there is to it um let's see going back here then we're going to investigate I'm going to just simply have you add a new a new item to it um that's all we're doing here so instead of finishing with 999 we're going to finish with 777 and you can see how that's done right here this is the only thing I want you to do um is to examine this and the difference between these two files when you modify we're going to have you actually enter a new one at the end very simple so just um I just want you to enter something after the 777 so just create you know basically a new one at the very end again not not too bad um and then when you do your make you'll do something very similar but instead at the very very end of your code I want you to um insert something in the middle of of the list not don't do them in order I want you to go through and and create exactly what we had and then insert something that's in the middle just by moving the pointers around so that's kind of the assignment there and and what I I'll expect there so th those those will all be outlined in the assignment um but I hope that makes sense uh please let me know if you have any questions pointers can be a little hairy but that's why we broke it up into a couple weeks here and I hope that these these walkthroughs will get you most of the way there if the reading didn't out right so that's kind of what I have uh on pointers uh kind of a nasty subject but let me know if I if I can help you with that at all it's probably one of the nastier things we'll get through but it's expected that you know it um and it's kind of fun to understand how memor is going and things like that so that that's what I have on that thank you