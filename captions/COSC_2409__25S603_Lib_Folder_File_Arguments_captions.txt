in our continuing lecture series on modules um we we talked about name spaces a little bit and and how things are named and how we can use you know things like name equals main to do unit testing um but it turns out that there's a little bit even more that we can do there before we do that I want to write just a just talk about a little bit of motivation uh for doing what we're about ready to explore which is of course executing um uh command line Python and being able to pass arguments into our python file directly um you might recall that we had a very kind of convoluted uh um folder structure here where I've got a bunch of examples I might and this might be you know something that's true in practice as well um where I've got uh just a bunch of different things I want to do uh in in a in a project um you know many modes of operation many ways we want to use the logic that we're investing our time and effort into and making sure it runs great well we want to reuse that so we might have a whole bunch of these you know places where we want to run different files like kind of what I was stumbling over a couple videos ago right here right um You Might Recall that we put our module right in this folder right in this folder um called SRC which stands for source file um SRC stands for source and it's a shorthand for Source um but I think it's a better practice personally to do things like this where you create a lib folder a library folder in your pro um in your in your uh folder structure and uh place your um place your your libraries there so we've got another Library here a very simple one that just does some Fibonacci Sequence stuff uh we got fib and FIB 2 where it's basically returning um uh the uh uh Fibonacci sequences uh uh the first one will write them up to end and then the second one will return them for usage uh so it one one is a essentally essentially a fruitless uh function where it does not return anything instead it prints it's kind of got that sight effect uh to it um and then the other one is something we could of course uh you know return the thing into a list in this case so we're going to Output a list um that we could then get um our Fibonacci Sequence from so that's the whole design of the whole function of course I don't even have a main tester here like we talked about this is underdeveloped for um you know where we were but it'll illustrate kind of what I want to talk about in this next bit um you'll notice that I've got uh this kind of program and this kind of program in here we're going to focus on this one so hopefully this part looks familiar where I'm importing Fibonacci here um as fibo that you probably haven't seen this uh kind of setup before where it has this word as or if you do um we certainly haven't covered it in this version of this class yet um this is an alias so instead of having to write Fibonacci which is kind of hard to spell sometimes and I can't remember if there's an A or an O here you can give it an an alias U that basically represents it here the other thing you may may not have seen yet is this dot syntax once I've done this I can basically address things in there by saying okay within fibo the Fibonacci uh you know fibo the the Alias for Fibonacci within that I want to go grab a method called FIB which is of course just our first um our first our our first uh version of this this method right here that's that's all we're doing let me go and close all of these just to kind of uh keep this uh again clean a little bit wrong one this was the one I want um so the the point being though is that we we import it here uh as fibo and then uh we we use it down here um in a couple different places uh in particular right here all right this should all be review except for maybe this as function which is of course just renaming it temporarily to make it easier on us not to have to type out the full file name and then this dot syntax where it's saying give me the uh the this fun function this is opposed to when we did the um import a function directly um where it would import the name space uh and we call the functions directly um this is just another way to do that uh I could certainly do either or though there's it's really your preference there's pros and cons to both the main points I wanted to talk about though is you might notice that Fibonacci here is no longer in source and as a matter of fact if I didn't do this little trick that I'm sharing with you here today um this would not run so let's go and delete this just for a second um and run this uh it uh actually will not work do you see no no module named Fibonacci and that's because it's not in the source directory here so what I can do is do this little pa uh little lookup trick that's essentially um uh putting this what's called on the system path system path is just a list of where it looks for things and there's a lot of python uh uh uh setup that goes on behind the scenes to make all this work where it can find modules that we download um and use um you know as as uh as external libraries um but we can also basically tack on this little bit right here this dot dot means go back One Directory um from where we are and then then tack on lib so it's basically saying tack on this folder this lib folder here to where you look for files and once we do that then this this will work um it's uh you'll see this is not an error by the way uh this is intended and I'm going to come back back to while this why this does this uh in just a bit um actually let's go ahead and I've got another little version of it here um that does this so this this will run this will run using this trick and you'll see we're getting output here doing exactly the same thing we did where we essentially um of course use this trick and of course just copy and paste this right or and you'll need to change it to whatever directory you have here um or you can put absolute pads in if you store your files somewhere else um this is a relative path from basically going back one and going into lib here um uh but uh the point is it's getting at this Fibonacci file by doing this um and then we get access to this and we using our old syntax where we're just importing FIB one and FIB two or fib and FIB two um and then we can run it right that's what's going on in this uh FIB named uh version of it uh but we can extend that even further um to basically uh do do a thing that I think I'm going to start to use when we turn in um homework and I'll probably even write our homework with this uh in this way because what you can do let me go and clear this out just to unclutter it for us um is instead of basically running this uh from uh waiting for user input um we could certainly write this where we're saying hey input a number and input you know it'll print out the Fibonacci sequence up to that number we could do that with our menu system that we just talked about in a recent video but another way we can do this and in a very uh uh nice design pattern is we can run of course we have to run Python and then you know we would want to uh run this command line that's what we're in um and when I run this by itself um it's basically saying okay we're taking in uh some input from the command line that's the this this new design pattern we're exploring here so this is a little bit different than all of the other programs we've seen What's Happening Here is it's basically using this cy. argv um these are argument values that come in from the command line let me show you how this is supposed to work for uh uh so if I put like 500 here we're going to get a completely different kind of output and the reason that works this of course works right it does what we want What's Happening Here is it's basically saying okay there's um there's system arguments system arguments are essentially everything that comes after the wor word python the first one is the file name itself so the first argument is always going to be um uh the file name itself but then we can give it any number of arguments afterwards in this case we're giving it a number right um and when we do that it uh it instead uh jumps over this if BL so this is basically why it says when I run it without the thing when I run it like this it's saying there's only there's only one argument being passed to this in that case the the file name um so it's printing this usage and it's of course and then it exits with an error that's what's going on here um that's why we see this but when I do it like this it jumps over this if block and says okay now I'm going to go grab the second value which of course as we know from previous study we can get with the index of one so this is again just a list of arguments coming in and if we get the second one we can grab that number and do something with it um and in this case we want to actually throw an error uh if it's less than zero because you don't do Fibonacci sequences less than zero um and uh it it'll Loop and do some cool things there uh or not Loop but give you a nice error message if this gets violated and then finally it uses that number and prints it out um in this way we can actually write test cases against this uh right coming from the uh the the command line um uh instead of writing those ourselves and we could use automated tools to do this um so I I could easily make this an assignment where your assignment might be write the Fibonacci sequence and I'm going to basically expect you to be able to take an argument here and I could write a program on the back end of that that then says I expect this kind of output or it needs to have you know the number 233 in it and the number 987 in it um and that'd be a way we could test that as well so a couple bits of things that we can do with modules and the main method um and then command line arguments um command line arguments are new but I think they're super valuable to know about because you can pass information away from around like this you can also um use files input to input and output uh uh in into and out of um into and out of python uh by giving it a file name where you could maybe have a data file that comes in and processes and then when you're you know say you had monthly payroll you could write a python file that takes a a file it's called April do you know payroll and or monthly. payroll and and runs it but then you could also write another version that says okay now I want maze payroll same format does the same thing but it's different data right so we could start to swap in and swap out our outputs and in that way we could modularize um our our logic away from our data and start to process in that um uh multiple multiple versions of of data using the same program and get a lot of code reuse there so uh just a little bit more on uh uh you know what this name's doing and what we can do with modules um not necessarily module module module related except for this little trick up here where we tuck away our file into a lib folder and separate our runner logic from our um Library logic but just a couple odds and ends that I think are very useful things that a lot of people uh use in Python that we don't really get to cover anywhere else in the in the course um and I think it's very important for you to know how to do that um so hopefully that's useful um if any of this did make sense or if you want to explore this further please let me know I'm throwing a lot of kind of abstract ideas at you in this unit it's not a very long unit it's not a very dense unit um but it's kind of a junk drawer of odds and ends that are useful things that we'll use going forward so thanks for that um talk to you soon