welcome back to C++ uh bells and whistles we'll call it for this week um one thing that's covered very quickly in the um classes unit that we don't really talk about um but is very important is this idea of um you know building reusable code and separating our logic um so I'm going to demonstrate how to do that just in a very high level um and reinforce a little reading uh for for part of this external files unit uh we'll talk about other kinds of external files so don't get those confused but this part is just about um separating our logic and keeping um you know reusable code uh in one one uh object file and then using it in another um going to our reading let's see here uh let's see this one um so during the classes in objects guided learning there's two um units that or two little subunits that I really want to have you uh to reinforce and maybe have you go back over um the big one is uh 7.8 um in the default file you might change you know as as the book changes and we reuse this video or such but it's really separating files for classes and this goes over the concept of header files and um and and including uh uh things like that we're not going to really go over to uh the use of header files but the main thing about those is that when we include them they basically get shoved in the uh middle of another file um you can think of it as kind of a a poor man's copy and paste for C++ code it's typically done for header files um which are important so we keep those separate uh just to not um bloat the uh the uh space of our um of our our of of our our custom work our our execution programs um other than that um it just does talk about you know the relationship between um you know header files and function definitions before we use them so the the short version of that is is if you if you have a file or a definition of a file in another place you need to at least give it the um the main definition of the file and we'll explore that just a bit um before you use it so we we basically uh put the signature of the file in the file we're trying to use or a header file and include it uh before we use it later on um uh so that's kind of it for this other than the fact that you know you have both and um and there's some vocabulary and things like that it's a pretty quick unit uh shouldn't take too long but I do want you to go back over it um the other one is this this little bit u in 710 on unit testing and it introduces this idea of a test bench program where we essentially write programs to test our classes before we uh use them even if even if we're the same User it's a good practice to do this because you might not necessarily use things in the uh same manner that you uh you the the the full scope of what what how they might be used um you you know we might just use something um you know once or twice in very specific cases in our first program but we might want to you know Define that user uh or that function or or functions in a manner that could be reused down the road or and this this is doubly true if you expect to have your functions be used by external output that you might not expect all of the corner cases so um this is a really good unit as well um to to go over so uh but that's really not the main point of this um you know certainly those are important topics uh but unit testing could be its whole unit on its own um but this is a good introduction to it and I I really do enjoy it uh the main thing I wanted to do though is to give a bit of a technical demo on how to actually do this in C++ with our g++ compiler so I've just set up a very simple program here um that um takes a sum function just a very simple sum function and we we um we actually Define it in an external file you can see my two files over here um so we we basically do all the Gory details of of this uh operation in this functions. CPP and in this case in this sum but we could put classes in here and things like that this is um it really doesn't um what we put in here uh isn't as important as how we we link these up so but as you're doing this especially for your final uh it' be it it probably make a lot of sense to both put these in uh your your classes and your functions and your member functions uh for those classes in an external file and then write a separate program Al together to test them outside of your your simulation um so this is a very simple function obviously uh the the point is not the complexity of the function but the fact that it it's in an external file we'll see how that can be re reused um but we just have some uh uh you know just summing up two numbers very uh this obviously shouldn't be too too too convoluted for you at this point of the the course and then in our main program um we we go ahead and include IO stream because we're going to uce a little output and then use our our standard name space um that we kind of use everywhere um just so we don't have to reference you know see out and things like that within there um but then we give this this this line is kind might be new if if you haven't done this work before or if you've done everything in one file where instead of defining the whole function here we just give it the signature and this just makes the main program or this file uh the the scope uh it makes it aware of that this this exists this could be in a header file and it often is um so this could be in um you know a functions uh. file which would include this line and it wouldn't be here and then we would just include it um using our include syntax that uh that we've covered before that would be basically copy and paste the header header Parts into this file so this is available um but in this case we we're just going to put it here explicitly um and then we just call you we use it the very simple mean we just take two numbers not to be confused with the ones we're passing in as parameters um um uh we're we're actually uh creating them here and then passing them into the function uh uh they just happen to use the same name but you don't have to give them the same name as they are in the function definition as a matter of fact this could be like number a like so and number B like so I guess I even made a typo um and you'll see here that we that this will still work so um but the to the main point um the easiest way to do this with g++ um is to call our compiler which is g++ down here and so I'm working down here in the console now you might and I apologize for the the length of this I wish I could trim this down I don't know how to do that actually I do I'll do this in a console uh which is a little shorter than the the poers shell so let's let's do it at the command problem but they work both the same oh I guess it's even worse never mind we'll do it in Powershell and close this U so let me bring that back oh dang it I wish I hadn't even well you know this might even be better because at least you can read it so this is all just the file path of what I'm doing so uh what you can do uh the easiest way to do this is just to do them all at once um so you could certainly do something like this where you do function um functions. CPP and main.cpp but the main thing you need to do when you do it like this is give it an output file and this is the executable that you'll be creating so let's go call this like main exact. exe because I'm on Windows uh we just use exe as you know the common uh executable format so if I run this you'll see that that um all runs and we we get main exact. exe and I usually give it a little bit different name just so I remember it and then we can of course just run this uh like so and we get we get our output it's no big deal right but let's pretend that we wanted to maintain functions separately so I'm going to go and clear this out and delete our uh main exec just for a second you can actually compile these separately and uh often it's good practice to do so where we might do something like um um g++ again still our compiler g++ and we can we can compile functions separately um and you'll see when I do that oh and but when you do that you need to give it the operation of C to compile that um explicitly basically it's saying we're not expecting an output yet um so if we run that let's go and close that just for now um we can see that functions gets a. o file created um this is um essentially bite code or or an executable it's binary it's a it's compiled but it's just for functions and then we can do the same thing for main here um so we can actually just run our same exact bit like so and we'll see a main one comes out so the difference here is that we can uh in instead of doing this we can link the two files then and it's actually done the exact same way um where we um we we just give it the the object files in in the same way instead of the source files modern compilers just do this for you you used to have to do this by hand all the time um and this will create our banding act this will do the linking of the of the two things for us um just just like it did before um and then just like before we can see that we get um an output uh you know of these two numbers being added together um so the main main point though is we could write other programs other than main here or we could even use main uh where we have different Mains in there to do unit testing and things like that or we could ship off the object uh here to other programs because it's basically ready to go at that point we would just need to call this um well let's actually just do that let's let's let's uh let's let's actually just make a copy of main so let's copy it paste it right like this and we'll have I'm going to rename it just to um uh let's just call it something else like so and let's change the numbers just a little bit let's call this 99 right so we can do the same exact operation we we um um but instead of compiling both we can just actually just do g++ and we can uh compile again our new one like that and we'll see the object file come out and then we can link those um instead of calling main here we'll call something else and we could actually do it that way as well um and then we'll call it main exact two just to differentiate between the two and we'll see that come out and we could just run that and we get a different number so you can see how you can reuse that same function file there um and that's kind of the co core of it it's really important when we get into bigger things like classes where you've tested the thing and it's just reusable code you're ready to go and you just want to use it um this is a big idea in abstraction right where we reuse these things and kind of shove them off and reuse them um but this is how you use external files to to you know make this much simpler you know that our functions could be this could be a huge file there could be multiple ones of them where we want to include all of these things so that's kind of how to do that I just wanted to write a quick video on that because I don't really cover it anywhere explicitly I kind of just do it going forward um so I wanted to take a pause here to do that um and and throw it and I'm going just going to shove this probably into our external files unit where we talk about reading and writing files but um uh at least we have a video to this effect for this so um hope that helps if if you haven't done that before thanks